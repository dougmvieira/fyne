{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"fyne documentation Welcome to fyne documentation! Please visit the user guide to learn about fyne or visit the reference for specific API documentation.","title":"Home"},{"location":"#fyne-documentation","text":"Welcome to fyne documentation! Please visit the user guide to learn about fyne or visit the reference for specific API documentation.","title":"fyne documentation"},{"location":"guide/","text":"User guide Models The models that are currently implemented in fyne are the Black-Scholes, Heston and Wishart models. In order to make notation clear, especially with the naming of the parameters, we state below the discounted underlying price dynamics of the models under the risk-neutral measure. Black-Scholes \\[ dS_t = \\sigma S_t dW_t \\] Heston \\begin{aligned} dS_t & = \\sqrt{V_t} S_t dW_t \\\\ dV_t & = \\kappa(\\theta - V_t)dt + \\nu \\sqrt{V_t}dZ_t \\\\ d[W, Z]_t & = \\rho dt \\end{aligned} \\begin{aligned} dS_t & = \\sqrt{V_t} S_t dW_t \\\\ dV_t & = \\kappa(\\theta - V_t)dt + \\nu \\sqrt{V_t}dZ_t \\\\ d[W, Z]_t & = \\rho dt \\end{aligned} Wishart \\begin{aligned} dS_t & = S_t \\mathrm{Tr} \\left( \\sqrt{V_t} \\left( dW_t R + dZ_t \\sqrt{I - RR^T} \\right) \\right) \\\\ dV_t & = \\left(\\beta QQ^T + M V_t + V_t M^T \\right) dt + \\sqrt{V_t} dW_t Q + Q^T dW_t^T \\sqrt{V_t} \\\\ d[W, Z]_t & = 0 \\end{aligned} \\begin{aligned} dS_t & = S_t \\mathrm{Tr} \\left( \\sqrt{V_t} \\left( dW_t R + dZ_t \\sqrt{I - RR^T} \\right) \\right) \\\\ dV_t & = \\left(\\beta QQ^T + M V_t + V_t M^T \\right) dt + \\sqrt{V_t} dW_t Q + Q^T dW_t^T \\sqrt{V_t} \\\\ d[W, Z]_t & = 0 \\end{aligned} Pricing Each model has its own pricing formula. The available pricing functions are: fyne.blackscholes.formula fyne.heston.formula These functions return the price of the option in monetary units. If implied volatility is needed, it can be evaluated with fyne.blackscholes.implied_vol {.interpreted-text role=\"func\"}. Example In this example, we compute the implied volatility smile according to the Heston model. import numpy as np import pandas as pd import plotly.express as px from fyne import blackscholes, heston underlying_price = 100.0 vol = 0.0457 params = (5.07, 0.0457, 0.48, -0.767) strikes, expiries = np.broadcast_arrays( np.linspace(80.0, 120.0, 40)[:, None], [0.1, 0.3, 1.0], ) option_prices = heston.formula( underlying_price, strikes, expiries, vol, *params ) implied_vols = blackscholes.implied_vol( underlying_price, strikes, expiries, option_prices ) data = pd.DataFrame( { \"expirie\": expiries.ravel(), \"strike\": strikes.ravel(), \"implied_vol\": implied_vols.ravel(), } ) fig = px.line( data, x=\"strike\", y=\"implied_vol\", color=\"expirie\", title=\"Heston volatility smile\", markers=True, ) fig.write_html( \"docs/heston_smile.html\", full_html=False, include_plotlyjs=\"cdn\", ) window.PlotlyConfig = {MathJaxConfig: 'local'}; window.PLOTLYENV=window.PLOTLYENV || {}; if (document.getElementById(\"8313ef44-16e1-440e-b45c-257ba8f03d65\")) { Plotly.newPlot( \"8313ef44-16e1-440e-b45c-257ba8f03d65\", [{\"hovertemplate\":\"expiries=0.1\\u003cbr\\u003estrikes=%{x}\\u003cbr\\u003eimplied_vols=%{y}\\u003cextra\\u003e\\u003c\\u002fextra\\u003e\",\"legendgroup\":\"0.1\",\"line\":{\"color\":\"#636efa\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"markers+lines\",\"name\":\"0.1\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[80.0,81.02564102564102,82.05128205128204,83.07692307692308,84.1025641025641,85.12820512820512,86.15384615384616,87.17948717948718,88.2051282051282,89.23076923076923,90.25641025641025,91.28205128205128,92.3076923076923,93.33333333333333,94.35897435897436,95.38461538461539,96.41025641025641,97.43589743589743,98.46153846153845,99.48717948717949,100.51282051282051,101.53846153846153,102.56410256410257,103.58974358974359,104.61538461538461,105.64102564102564,106.66666666666666,107.6923076923077,108.71794871794872,109.74358974358974,110.76923076923077,111.7948717948718,112.82051282051282,113.84615384615384,114.87179487179486,115.8974358974359,116.92307692307692,117.94871794871794,118.97435897435898,120.0],\"xaxis\":\"x\",\"y\":[0.2790752161790672,0.27573185863561844,0.2723768556409474,0.2690072373840524,0.26562170543733915,0.26221829061641627,0.2587956984990216,0.25535249711675406,0.25188631425652086,0.2483961963056626,0.2448803025695524,0.24133702326448742,0.2377647814859705,0.23416216001049792,0.2305278664536619,0.22686086047372142,0.22316045590312988,0.21942647127963957,0.2156594342077649,0.21186086468553375,0.20803359061440727,0.204182268297397,0.2003139786019842,0.1964388678998573,0.19257098531517716,0.1887290423060454,0.1849369792684026,0.18122424667430148,0.17762415565157394,0.17417419656352956,0.17091039746809777,0.1678671179665443,0.16506985951379874,0.16253881823659147,0.16027660553362616,0.15828566440850084,0.15655706603677336,0.15506908983634268,0.1538449820103453,null],\"yaxis\":\"y\",\"type\":\"scatter\"},{\"hovertemplate\":\"expiries=0.3\\u003cbr\\u003estrikes=%{x}\\u003cbr\\u003eimplied_vols=%{y}\\u003cextra\\u003e\\u003c\\u002fextra\\u003e\",\"legendgroup\":\"0.3\",\"line\":{\"color\":\"#EF553B\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"markers+lines\",\"name\":\"0.3\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[80.0,81.02564102564102,82.05128205128204,83.07692307692308,84.1025641025641,85.12820512820512,86.15384615384616,87.17948717948718,88.2051282051282,89.23076923076923,90.25641025641025,91.28205128205128,92.3076923076923,93.33333333333333,94.35897435897436,95.38461538461539,96.41025641025641,97.43589743589743,98.46153846153845,99.48717948717949,100.51282051282051,101.53846153846153,102.56410256410257,103.58974358974359,104.61538461538461,105.64102564102564,106.66666666666666,107.6923076923077,108.71794871794872,109.74358974358974,110.76923076923077,111.7948717948718,112.82051282051282,113.84615384615384,114.87179487179486,115.8974358974359,116.92307692307692,117.94871794871794,118.97435897435898,120.0],\"xaxis\":\"x\",\"y\":[0.2615275462577199,0.2587190800472038,0.25591020069348375,0.2531003537247431,0.2502890492107742,0.24747575344672773,0.24466011868785506,0.24184185685243417,0.23902044528086638,0.23619592991088761,0.23336813508220317,0.23053707491504907,0.22770289533134108,0.22486589333940812,0.22202654047630338,0.21918550908533593,0.21634370113407836,0.21350228001438482,0.21066270540274754,0.20782677017357795,0.20499664068192996,0.20217489493616,0.19936456235295522,0.19656916253495402,0.1937927369958887,0.19103987476575007,0.18831572683708625,0.18562600600074078,0.18297696640168992,0.18037535897631557,0.1778283564705533,0.17534345327101045,0.17292837199263356,0.17059063458586193,0.16833789344411695,0.16617719632040273,0.1641149439388359,0.16215680056568618,0.16030732982082133,0.15857007888809635],\"yaxis\":\"y\",\"type\":\"scatter\"},{\"hovertemplate\":\"expiries=1.0\\u003cbr\\u003estrikes=%{x}\\u003cbr\\u003eimplied_vols=%{y}\\u003cextra\\u003e\\u003c\\u002fextra\\u003e\",\"legendgroup\":\"1.0\",\"line\":{\"color\":\"#00cc96\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"markers+lines\",\"name\":\"1.0\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[80.0,81.02564102564102,82.05128205128204,83.07692307692308,84.1025641025641,85.12820512820512,86.15384615384616,87.17948717948718,88.2051282051282,89.23076923076923,90.25641025641025,91.28205128205128,92.3076923076923,93.33333333333333,94.35897435897436,95.38461538461539,96.41025641025641,97.43589743589743,98.46153846153845,99.48717948717949,100.51282051282051,101.53846153846153,102.56410256410257,103.58974358974359,104.61538461538461,105.64102564102564,106.66666666666666,107.6923076923077,108.71794871794872,109.74358974358974,110.76923076923077,111.7948717948718,112.82051282051282,113.84615384615384,114.87179487179486,115.8974358974359,116.92307692307692,117.94871794871794,118.97435897435898,120.0],\"xaxis\":\"x\",\"y\":[0.234365803492235,0.2327913734134055,0.23123011080460865,0.2296818339369776,0.22814637413112743,0.22662357537997105,0.22511329402501795,0.22361539849248685,0.2221297690638975,0.22065629764438144,0.2191948875112917,0.21774545305718931,0.21630791955683212,0.2148822229757745,0.21346830981260193,0.21206613695218424,0.2106756715139416,0.20929689069501123,0.20792977408868465,0.20657434092428625,0.20523057564351793,0.2038984946916552,0.2025781439637356,0.20126953711889803,0.19997272459804574,0.19868775863696483,0.19741470008079415,0.19615361817392246,0.19490459031935645,0.19366770179805018,0.19244304553625508,0.19123072173334005,0.1900308376836274,0.18884350740861827,0.18766885127268795,0.1865069955239509,0.1853580718161166,0.18422221674379122,0.18309957135585542,0.18199028077663437],\"yaxis\":\"y\",\"type\":\"scatter\"}], {\"template\":{\"data\":{\"histogram2dcontour\":[{\"type\":\"histogram2dcontour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"choropleth\":[{\"type\":\"choropleth\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"histogram2d\":[{\"type\":\"histogram2d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmap\":[{\"type\":\"heatmap\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmapgl\":[{\"type\":\"heatmapgl\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"contourcarpet\":[{\"type\":\"contourcarpet\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"contour\":[{\"type\":\"contour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"surface\":[{\"type\":\"surface\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"mesh3d\":[{\"type\":\"mesh3d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"scatter\":[{\"fillpattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2},\"type\":\"scatter\"}],\"parcoords\":[{\"type\":\"parcoords\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolargl\":[{\"type\":\"scatterpolargl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"bar\":[{\"error_x\":{\"color\":\"#2a3f5f\"},\"error_y\":{\"color\":\"#2a3f5f\"},\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"bar\"}],\"scattergeo\":[{\"type\":\"scattergeo\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolar\":[{\"type\":\"scatterpolar\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"histogram\":[{\"marker\":{\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"histogram\"}],\"scattergl\":[{\"type\":\"scattergl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatter3d\":[{\"type\":\"scatter3d\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattermapbox\":[{\"type\":\"scattermapbox\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterternary\":[{\"type\":\"scatterternary\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattercarpet\":[{\"type\":\"scattercarpet\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"carpet\":[{\"aaxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"baxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"type\":\"carpet\"}],\"table\":[{\"cells\":{\"fill\":{\"color\":\"#EBF0F8\"},\"line\":{\"color\":\"white\"}},\"header\":{\"fill\":{\"color\":\"#C8D4E3\"},\"line\":{\"color\":\"white\"}},\"type\":\"table\"}],\"barpolar\":[{\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"barpolar\"}],\"pie\":[{\"automargin\":true,\"type\":\"pie\"}]},\"layout\":{\"autotypenumbers\":\"strict\",\"colorway\":[\"#636efa\",\"#EF553B\",\"#00cc96\",\"#ab63fa\",\"#FFA15A\",\"#19d3f3\",\"#FF6692\",\"#B6E880\",\"#FF97FF\",\"#FECB52\"],\"font\":{\"color\":\"#2a3f5f\"},\"hovermode\":\"closest\",\"hoverlabel\":{\"align\":\"left\"},\"paper_bgcolor\":\"white\",\"plot_bgcolor\":\"#E5ECF6\",\"polar\":{\"bgcolor\":\"#E5ECF6\",\"angularaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"radialaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"ternary\":{\"bgcolor\":\"#E5ECF6\",\"aaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"baxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"caxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"coloraxis\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"colorscale\":{\"sequential\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"sequentialminus\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"diverging\":[[0,\"#8e0152\"],[0.1,\"#c51b7d\"],[0.2,\"#de77ae\"],[0.3,\"#f1b6da\"],[0.4,\"#fde0ef\"],[0.5,\"#f7f7f7\"],[0.6,\"#e6f5d0\"],[0.7,\"#b8e186\"],[0.8,\"#7fbc41\"],[0.9,\"#4d9221\"],[1,\"#276419\"]]},\"xaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"yaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"scene\":{\"xaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"yaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"zaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2}},\"shapedefaults\":{\"line\":{\"color\":\"#2a3f5f\"}},\"annotationdefaults\":{\"arrowcolor\":\"#2a3f5f\",\"arrowhead\":0,\"arrowwidth\":1},\"geo\":{\"bgcolor\":\"white\",\"landcolor\":\"#E5ECF6\",\"subunitcolor\":\"white\",\"showland\":true,\"showlakes\":true,\"lakecolor\":\"white\"},\"title\":{\"x\":0.05},\"mapbox\":{\"style\":\"light\"}}},\"xaxis\":{\"anchor\":\"y\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"strikes\"}},\"yaxis\":{\"anchor\":\"x\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"implied_vols\"}},\"legend\":{\"title\":{\"text\":\"expiries\"},\"tracegroupgap\":0},\"title\":{\"text\":\"Heston volatility smile\"}}, {\"responsive\": true} ) }; Greeks Greeks are usually associated to the derivatives of the Black-Scholes formula. However, Greeks can be computed according to other models as well. The following are the available Greeks in fyne : fyne.blackscholes.delta fyne.blackscholes.vega fyne.heston.delta fyne.heston.vega Calibration In fyne we distinguish two types of calibration: Cross-sectional Calibration from options prices at a single point in time Panel Calibration from options prices at a multiple points in time Besides, calibration can recover the full parameter set and unobservable state variables or just the unobservable state variables. The available calibration functions are the following: fyne.heston.calibration_crosssectional fyne.heston.calibration_panel fyne.heston.calibration_vol","title":"User guide"},{"location":"guide/#user-guide","text":"","title":"User guide"},{"location":"guide/#models","text":"The models that are currently implemented in fyne are the Black-Scholes, Heston and Wishart models. In order to make notation clear, especially with the naming of the parameters, we state below the discounted underlying price dynamics of the models under the risk-neutral measure. Black-Scholes \\[ dS_t = \\sigma S_t dW_t \\] Heston \\begin{aligned} dS_t & = \\sqrt{V_t} S_t dW_t \\\\ dV_t & = \\kappa(\\theta - V_t)dt + \\nu \\sqrt{V_t}dZ_t \\\\ d[W, Z]_t & = \\rho dt \\end{aligned} \\begin{aligned} dS_t & = \\sqrt{V_t} S_t dW_t \\\\ dV_t & = \\kappa(\\theta - V_t)dt + \\nu \\sqrt{V_t}dZ_t \\\\ d[W, Z]_t & = \\rho dt \\end{aligned} Wishart \\begin{aligned} dS_t & = S_t \\mathrm{Tr} \\left( \\sqrt{V_t} \\left( dW_t R + dZ_t \\sqrt{I - RR^T} \\right) \\right) \\\\ dV_t & = \\left(\\beta QQ^T + M V_t + V_t M^T \\right) dt + \\sqrt{V_t} dW_t Q + Q^T dW_t^T \\sqrt{V_t} \\\\ d[W, Z]_t & = 0 \\end{aligned} \\begin{aligned} dS_t & = S_t \\mathrm{Tr} \\left( \\sqrt{V_t} \\left( dW_t R + dZ_t \\sqrt{I - RR^T} \\right) \\right) \\\\ dV_t & = \\left(\\beta QQ^T + M V_t + V_t M^T \\right) dt + \\sqrt{V_t} dW_t Q + Q^T dW_t^T \\sqrt{V_t} \\\\ d[W, Z]_t & = 0 \\end{aligned}","title":"Models"},{"location":"guide/#pricing","text":"Each model has its own pricing formula. The available pricing functions are: fyne.blackscholes.formula fyne.heston.formula These functions return the price of the option in monetary units. If implied volatility is needed, it can be evaluated with fyne.blackscholes.implied_vol {.interpreted-text role=\"func\"}.","title":"Pricing"},{"location":"guide/#example","text":"In this example, we compute the implied volatility smile according to the Heston model. import numpy as np import pandas as pd import plotly.express as px from fyne import blackscholes, heston underlying_price = 100.0 vol = 0.0457 params = (5.07, 0.0457, 0.48, -0.767) strikes, expiries = np.broadcast_arrays( np.linspace(80.0, 120.0, 40)[:, None], [0.1, 0.3, 1.0], ) option_prices = heston.formula( underlying_price, strikes, expiries, vol, *params ) implied_vols = blackscholes.implied_vol( underlying_price, strikes, expiries, option_prices ) data = pd.DataFrame( { \"expirie\": expiries.ravel(), \"strike\": strikes.ravel(), \"implied_vol\": implied_vols.ravel(), } ) fig = px.line( data, x=\"strike\", y=\"implied_vol\", color=\"expirie\", title=\"Heston volatility smile\", markers=True, ) fig.write_html( \"docs/heston_smile.html\", full_html=False, include_plotlyjs=\"cdn\", ) window.PlotlyConfig = {MathJaxConfig: 'local'}; window.PLOTLYENV=window.PLOTLYENV || {}; if (document.getElementById(\"8313ef44-16e1-440e-b45c-257ba8f03d65\")) { Plotly.newPlot( \"8313ef44-16e1-440e-b45c-257ba8f03d65\", [{\"hovertemplate\":\"expiries=0.1\\u003cbr\\u003estrikes=%{x}\\u003cbr\\u003eimplied_vols=%{y}\\u003cextra\\u003e\\u003c\\u002fextra\\u003e\",\"legendgroup\":\"0.1\",\"line\":{\"color\":\"#636efa\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"markers+lines\",\"name\":\"0.1\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[80.0,81.02564102564102,82.05128205128204,83.07692307692308,84.1025641025641,85.12820512820512,86.15384615384616,87.17948717948718,88.2051282051282,89.23076923076923,90.25641025641025,91.28205128205128,92.3076923076923,93.33333333333333,94.35897435897436,95.38461538461539,96.41025641025641,97.43589743589743,98.46153846153845,99.48717948717949,100.51282051282051,101.53846153846153,102.56410256410257,103.58974358974359,104.61538461538461,105.64102564102564,106.66666666666666,107.6923076923077,108.71794871794872,109.74358974358974,110.76923076923077,111.7948717948718,112.82051282051282,113.84615384615384,114.87179487179486,115.8974358974359,116.92307692307692,117.94871794871794,118.97435897435898,120.0],\"xaxis\":\"x\",\"y\":[0.2790752161790672,0.27573185863561844,0.2723768556409474,0.2690072373840524,0.26562170543733915,0.26221829061641627,0.2587956984990216,0.25535249711675406,0.25188631425652086,0.2483961963056626,0.2448803025695524,0.24133702326448742,0.2377647814859705,0.23416216001049792,0.2305278664536619,0.22686086047372142,0.22316045590312988,0.21942647127963957,0.2156594342077649,0.21186086468553375,0.20803359061440727,0.204182268297397,0.2003139786019842,0.1964388678998573,0.19257098531517716,0.1887290423060454,0.1849369792684026,0.18122424667430148,0.17762415565157394,0.17417419656352956,0.17091039746809777,0.1678671179665443,0.16506985951379874,0.16253881823659147,0.16027660553362616,0.15828566440850084,0.15655706603677336,0.15506908983634268,0.1538449820103453,null],\"yaxis\":\"y\",\"type\":\"scatter\"},{\"hovertemplate\":\"expiries=0.3\\u003cbr\\u003estrikes=%{x}\\u003cbr\\u003eimplied_vols=%{y}\\u003cextra\\u003e\\u003c\\u002fextra\\u003e\",\"legendgroup\":\"0.3\",\"line\":{\"color\":\"#EF553B\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"markers+lines\",\"name\":\"0.3\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[80.0,81.02564102564102,82.05128205128204,83.07692307692308,84.1025641025641,85.12820512820512,86.15384615384616,87.17948717948718,88.2051282051282,89.23076923076923,90.25641025641025,91.28205128205128,92.3076923076923,93.33333333333333,94.35897435897436,95.38461538461539,96.41025641025641,97.43589743589743,98.46153846153845,99.48717948717949,100.51282051282051,101.53846153846153,102.56410256410257,103.58974358974359,104.61538461538461,105.64102564102564,106.66666666666666,107.6923076923077,108.71794871794872,109.74358974358974,110.76923076923077,111.7948717948718,112.82051282051282,113.84615384615384,114.87179487179486,115.8974358974359,116.92307692307692,117.94871794871794,118.97435897435898,120.0],\"xaxis\":\"x\",\"y\":[0.2615275462577199,0.2587190800472038,0.25591020069348375,0.2531003537247431,0.2502890492107742,0.24747575344672773,0.24466011868785506,0.24184185685243417,0.23902044528086638,0.23619592991088761,0.23336813508220317,0.23053707491504907,0.22770289533134108,0.22486589333940812,0.22202654047630338,0.21918550908533593,0.21634370113407836,0.21350228001438482,0.21066270540274754,0.20782677017357795,0.20499664068192996,0.20217489493616,0.19936456235295522,0.19656916253495402,0.1937927369958887,0.19103987476575007,0.18831572683708625,0.18562600600074078,0.18297696640168992,0.18037535897631557,0.1778283564705533,0.17534345327101045,0.17292837199263356,0.17059063458586193,0.16833789344411695,0.16617719632040273,0.1641149439388359,0.16215680056568618,0.16030732982082133,0.15857007888809635],\"yaxis\":\"y\",\"type\":\"scatter\"},{\"hovertemplate\":\"expiries=1.0\\u003cbr\\u003estrikes=%{x}\\u003cbr\\u003eimplied_vols=%{y}\\u003cextra\\u003e\\u003c\\u002fextra\\u003e\",\"legendgroup\":\"1.0\",\"line\":{\"color\":\"#00cc96\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"markers+lines\",\"name\":\"1.0\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[80.0,81.02564102564102,82.05128205128204,83.07692307692308,84.1025641025641,85.12820512820512,86.15384615384616,87.17948717948718,88.2051282051282,89.23076923076923,90.25641025641025,91.28205128205128,92.3076923076923,93.33333333333333,94.35897435897436,95.38461538461539,96.41025641025641,97.43589743589743,98.46153846153845,99.48717948717949,100.51282051282051,101.53846153846153,102.56410256410257,103.58974358974359,104.61538461538461,105.64102564102564,106.66666666666666,107.6923076923077,108.71794871794872,109.74358974358974,110.76923076923077,111.7948717948718,112.82051282051282,113.84615384615384,114.87179487179486,115.8974358974359,116.92307692307692,117.94871794871794,118.97435897435898,120.0],\"xaxis\":\"x\",\"y\":[0.234365803492235,0.2327913734134055,0.23123011080460865,0.2296818339369776,0.22814637413112743,0.22662357537997105,0.22511329402501795,0.22361539849248685,0.2221297690638975,0.22065629764438144,0.2191948875112917,0.21774545305718931,0.21630791955683212,0.2148822229757745,0.21346830981260193,0.21206613695218424,0.2106756715139416,0.20929689069501123,0.20792977408868465,0.20657434092428625,0.20523057564351793,0.2038984946916552,0.2025781439637356,0.20126953711889803,0.19997272459804574,0.19868775863696483,0.19741470008079415,0.19615361817392246,0.19490459031935645,0.19366770179805018,0.19244304553625508,0.19123072173334005,0.1900308376836274,0.18884350740861827,0.18766885127268795,0.1865069955239509,0.1853580718161166,0.18422221674379122,0.18309957135585542,0.18199028077663437],\"yaxis\":\"y\",\"type\":\"scatter\"}], {\"template\":{\"data\":{\"histogram2dcontour\":[{\"type\":\"histogram2dcontour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"choropleth\":[{\"type\":\"choropleth\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"histogram2d\":[{\"type\":\"histogram2d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmap\":[{\"type\":\"heatmap\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmapgl\":[{\"type\":\"heatmapgl\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"contourcarpet\":[{\"type\":\"contourcarpet\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"contour\":[{\"type\":\"contour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"surface\":[{\"type\":\"surface\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"mesh3d\":[{\"type\":\"mesh3d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"scatter\":[{\"fillpattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2},\"type\":\"scatter\"}],\"parcoords\":[{\"type\":\"parcoords\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolargl\":[{\"type\":\"scatterpolargl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"bar\":[{\"error_x\":{\"color\":\"#2a3f5f\"},\"error_y\":{\"color\":\"#2a3f5f\"},\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"bar\"}],\"scattergeo\":[{\"type\":\"scattergeo\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolar\":[{\"type\":\"scatterpolar\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"histogram\":[{\"marker\":{\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"histogram\"}],\"scattergl\":[{\"type\":\"scattergl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatter3d\":[{\"type\":\"scatter3d\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattermapbox\":[{\"type\":\"scattermapbox\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterternary\":[{\"type\":\"scatterternary\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattercarpet\":[{\"type\":\"scattercarpet\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"carpet\":[{\"aaxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"baxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"type\":\"carpet\"}],\"table\":[{\"cells\":{\"fill\":{\"color\":\"#EBF0F8\"},\"line\":{\"color\":\"white\"}},\"header\":{\"fill\":{\"color\":\"#C8D4E3\"},\"line\":{\"color\":\"white\"}},\"type\":\"table\"}],\"barpolar\":[{\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"barpolar\"}],\"pie\":[{\"automargin\":true,\"type\":\"pie\"}]},\"layout\":{\"autotypenumbers\":\"strict\",\"colorway\":[\"#636efa\",\"#EF553B\",\"#00cc96\",\"#ab63fa\",\"#FFA15A\",\"#19d3f3\",\"#FF6692\",\"#B6E880\",\"#FF97FF\",\"#FECB52\"],\"font\":{\"color\":\"#2a3f5f\"},\"hovermode\":\"closest\",\"hoverlabel\":{\"align\":\"left\"},\"paper_bgcolor\":\"white\",\"plot_bgcolor\":\"#E5ECF6\",\"polar\":{\"bgcolor\":\"#E5ECF6\",\"angularaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"radialaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"ternary\":{\"bgcolor\":\"#E5ECF6\",\"aaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"baxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"caxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"coloraxis\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"colorscale\":{\"sequential\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"sequentialminus\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"diverging\":[[0,\"#8e0152\"],[0.1,\"#c51b7d\"],[0.2,\"#de77ae\"],[0.3,\"#f1b6da\"],[0.4,\"#fde0ef\"],[0.5,\"#f7f7f7\"],[0.6,\"#e6f5d0\"],[0.7,\"#b8e186\"],[0.8,\"#7fbc41\"],[0.9,\"#4d9221\"],[1,\"#276419\"]]},\"xaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"yaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"scene\":{\"xaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"yaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"zaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2}},\"shapedefaults\":{\"line\":{\"color\":\"#2a3f5f\"}},\"annotationdefaults\":{\"arrowcolor\":\"#2a3f5f\",\"arrowhead\":0,\"arrowwidth\":1},\"geo\":{\"bgcolor\":\"white\",\"landcolor\":\"#E5ECF6\",\"subunitcolor\":\"white\",\"showland\":true,\"showlakes\":true,\"lakecolor\":\"white\"},\"title\":{\"x\":0.05},\"mapbox\":{\"style\":\"light\"}}},\"xaxis\":{\"anchor\":\"y\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"strikes\"}},\"yaxis\":{\"anchor\":\"x\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"implied_vols\"}},\"legend\":{\"title\":{\"text\":\"expiries\"},\"tracegroupgap\":0},\"title\":{\"text\":\"Heston volatility smile\"}}, {\"responsive\": true} ) };","title":"Example"},{"location":"guide/#greeks","text":"Greeks are usually associated to the derivatives of the Black-Scholes formula. However, Greeks can be computed according to other models as well. The following are the available Greeks in fyne : fyne.blackscholes.delta fyne.blackscholes.vega fyne.heston.delta fyne.heston.vega","title":"Greeks"},{"location":"guide/#calibration","text":"In fyne we distinguish two types of calibration: Cross-sectional Calibration from options prices at a single point in time Panel Calibration from options prices at a multiple points in time Besides, calibration can recover the full parameter set and unobservable state variables or just the unobservable state variables. The available calibration functions are the following: fyne.heston.calibration_crosssectional fyne.heston.calibration_panel fyne.heston.calibration_vol","title":"Calibration"},{"location":"reference/","text":"Reference The Python module for option pricing with affine processes Please see below the documentation for the implemented affine models. fyne.blackscholes fyne.heston fyne.wishart","title":"Index"},{"location":"reference/#reference","text":"The Python module for option pricing with affine processes Please see below the documentation for the implemented affine models. fyne.blackscholes fyne.heston fyne.wishart","title":"Reference"},{"location":"reference/blackscholes/","text":"Black-Scholes model delta ( underlying_price , strike , expiry , sigma , put = False ) Black-Scholes Greek delta Computes the Greek delta of the option -- i.e. the option price sensitivity with respect to its underlying price -- according to the Black-Scholes model. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. put : bool, optional Whether the option is a put option. Defaults to False . Returns float Greek delta according to Black-Scholes formula. Example import numpy as np from fyne import blackscholes sigma = 0.2 underlying_price = 100. strike = 90. expiry = 0.5 call_delta = blackscholes.delta( ... underlying_price, strike, expiry, sigma ... ) np.round(call_delta, 2) 0.79 put_delta = blackscholes.delta( ... underlying_price, strike, expiry, sigma, put=True ... ) np.round(put_delta, 2) -0.21 Source code in src/fyne/blackscholes.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def delta ( underlying_price , strike , expiry , sigma , put = False ): \"\"\"Black-Scholes Greek delta Computes the Greek delta of the option -- i.e. the option price sensitivity with respect to its underlying price -- according to the Black-Scholes model. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Greek delta according to Black-Scholes formula. Example ------- >>> import numpy as np >>> from fyne import blackscholes >>> sigma = 0.2 >>> underlying_price = 100. >>> strike = 90. >>> expiry = 0.5 >>> call_delta = blackscholes.delta( ... underlying_price, strike, expiry, sigma ... ) >>> np.round(call_delta, 2) 0.79 >>> put_delta = blackscholes.delta( ... underlying_price, strike, expiry, sigma, put=True ... ) >>> np.round(put_delta, 2) -0.21 \"\"\" k = np . array ( np . log ( strike / underlying_price )) expiry , sigma = map ( np . array , ( expiry , sigma )) call_delta = _reduced_delta ( k , expiry , sigma ) return common . _put_call_parity_delta ( call_delta , put ) formula ( underlying_price , strike , expiry , sigma , put = False ) Black-Scholes formula Computes the price of the option according to the Black-Scholes formula. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. put : bool, optional Whether the option is a put option. Defaults to False . Returns float Option price according to Black-Scholes formula. Example import numpy as np from fyne import blackscholes sigma = 0.2 underlying_price = 100. strike = 90. expiry = 0.5 call_price = blackscholes.formula(underlying_price, strike, expiry, ... sigma) np.round(call_price, 2) 11.77 put_price = blackscholes.formula(underlying_price, strike, expiry, ... sigma, put=True) np.round(put_price, 2) 1.77 Source code in src/fyne/blackscholes.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def formula ( underlying_price , strike , expiry , sigma , put = False ): \"\"\"Black-Scholes formula Computes the price of the option according to the Black-Scholes formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option price according to Black-Scholes formula. Example ------- >>> import numpy as np >>> from fyne import blackscholes >>> sigma = 0.2 >>> underlying_price = 100. >>> strike = 90. >>> expiry = 0.5 >>> call_price = blackscholes.formula(underlying_price, strike, expiry, ... sigma) >>> np.round(call_price, 2) 11.77 >>> put_price = blackscholes.formula(underlying_price, strike, expiry, ... sigma, put=True) >>> np.round(put_price, 2) 1.77 \"\"\" k = np . array ( np . log ( strike / underlying_price )) expiry , sigma = map ( np . array , ( expiry , sigma )) call = _reduced_formula ( k , expiry , sigma ) * underlying_price return common . _put_call_parity ( call , underlying_price , strike , put ) implied_vol ( underlying_price , strike , expiry , option_price , put = False , assert_no_arbitrage = True ) Implied volatility function Inverts the Black-Scholes formula to find the volatility that matches the given option price. The implied volatility is computed using Newton's method. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. option_price : float Option price according to Black-Scholes formula. put : bool, optional Whether the option is a put option. Defaults to False . assert_no_arbitrage : bool, optional Whether to throw an exception upon no arbitrage bounds violation. Defaults to True . Returns float Implied volatility. Example import numpy as np from fyne import blackscholes call_price = 11.77 put_price = 1.77 underlying_price = 100. strike = 90. expiry = 0.5 implied_vol = blackscholes.implied_vol(underlying_price, strike, ... expiry, call_price) np.round(implied_vol, 2) 0.2 implied_vol = blackscholes.implied_vol(underlying_price, strike, ... expiry, put_price, put=True) np.round(implied_vol, 2) 0.2 Source code in src/fyne/blackscholes.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def implied_vol ( underlying_price , strike , expiry , option_price , put = False , assert_no_arbitrage = True , ): \"\"\"Implied volatility function Inverts the Black-Scholes formula to find the volatility that matches the given option price. The implied volatility is computed using Newton's method. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. option_price : float Option price according to Black-Scholes formula. put : bool, optional Whether the option is a put option. Defaults to `False`. assert_no_arbitrage : bool, optional Whether to throw an exception upon no arbitrage bounds violation. Defaults to `True`. Returns ------- float Implied volatility. Example ------- >>> import numpy as np >>> from fyne import blackscholes >>> call_price = 11.77 >>> put_price = 1.77 >>> underlying_price = 100. >>> strike = 90. >>> expiry = 0.5 >>> implied_vol = blackscholes.implied_vol(underlying_price, strike, ... expiry, call_price) >>> np.round(implied_vol, 2) 0.2 >>> implied_vol = blackscholes.implied_vol(underlying_price, strike, ... expiry, put_price, put=True) >>> np.round(implied_vol, 2) 0.2 \"\"\" call = common . _put_call_parity_reverse ( option_price , underlying_price , strike , put ) if assert_no_arbitrage : common . _assert_no_arbitrage ( underlying_price , call , strike ) k = np . array ( np . log ( strike / underlying_price )) c = np . array ( call / underlying_price ) k , expiry , c = np . broadcast_arrays ( k , expiry , c ) is_otm = k > 0 k [ is_otm ] = - k [ is_otm ] c [ is_otm ] = 1 + np . exp ( k [ is_otm ]) * ( c [ is_otm ] - 1 ) noarb_mask = ~ np . any ( common . _check_arbitrage ( underlying_price , call , strike ), axis = 0 ) noarb_mask &= ~ np . any ( tuple ( map ( np . isnan , ( k , expiry , c ))), axis = 0 ) iv0 = np . maximum ( norm . ppf ( c [ noarb_mask ]), c [ noarb_mask ]) / np . sqrt ( expiry [ noarb_mask ] ) iv = np . full ( c . shape , np . nan ) iv [ noarb_mask ] = _reduced_implied_vol ( k [ noarb_mask ], expiry [ noarb_mask ], c [ noarb_mask ], iv0 ) return iv vega ( underlying_price , strike , expiry , sigma ) Black-Scholes Greek vega Computes the Greek vega of the option -- i.e. the option price sensitivity with respect to its volatility parameter -- according to the Black-Scholes model. Note that the Greek vega is the same for calls and puts. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. Returns float Greek vega according to Black-Scholes formula. Example import numpy as np from fyne import blackscholes sigma = 0.2 underlying_price = 100. strike = 90. maturity = 0.5 vega = blackscholes.vega(underlying_price, strike, maturity, sigma) np.round(vega, 2) 20.23 Source code in src/fyne/blackscholes.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def vega ( underlying_price , strike , expiry , sigma ): \"\"\"Black-Scholes Greek vega Computes the Greek vega of the option -- i.e. the option price sensitivity with respect to its volatility parameter -- according to the Black-Scholes model. Note that the Greek vega is the same for calls and puts. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. Returns ------- float Greek vega according to Black-Scholes formula. Example ------- >>> import numpy as np >>> from fyne import blackscholes >>> sigma = 0.2 >>> underlying_price = 100. >>> strike = 90. >>> maturity = 0.5 >>> vega = blackscholes.vega(underlying_price, strike, maturity, sigma) >>> np.round(vega, 2) 20.23 \"\"\" k = np . array ( np . log ( strike / underlying_price )) expiry , sigma = map ( np . array , ( expiry , sigma )) return _reduced_vega ( k , expiry , sigma ) * underlying_price","title":"Black-Scholes model"},{"location":"reference/blackscholes/#black-scholes-model","text":"","title":"Black-Scholes model"},{"location":"reference/blackscholes/#fyne.blackscholes.delta","text":"Black-Scholes Greek delta Computes the Greek delta of the option -- i.e. the option price sensitivity with respect to its underlying price -- according to the Black-Scholes model.","title":"delta()"},{"location":"reference/blackscholes/#fyne.blackscholes.delta--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. put : bool, optional Whether the option is a put option. Defaults to False .","title":"Parameters"},{"location":"reference/blackscholes/#fyne.blackscholes.delta--returns","text":"float Greek delta according to Black-Scholes formula.","title":"Returns"},{"location":"reference/blackscholes/#fyne.blackscholes.delta--example","text":"import numpy as np from fyne import blackscholes sigma = 0.2 underlying_price = 100. strike = 90. expiry = 0.5 call_delta = blackscholes.delta( ... underlying_price, strike, expiry, sigma ... ) np.round(call_delta, 2) 0.79 put_delta = blackscholes.delta( ... underlying_price, strike, expiry, sigma, put=True ... ) np.round(put_delta, 2) -0.21 Source code in src/fyne/blackscholes.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def delta ( underlying_price , strike , expiry , sigma , put = False ): \"\"\"Black-Scholes Greek delta Computes the Greek delta of the option -- i.e. the option price sensitivity with respect to its underlying price -- according to the Black-Scholes model. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Greek delta according to Black-Scholes formula. Example ------- >>> import numpy as np >>> from fyne import blackscholes >>> sigma = 0.2 >>> underlying_price = 100. >>> strike = 90. >>> expiry = 0.5 >>> call_delta = blackscholes.delta( ... underlying_price, strike, expiry, sigma ... ) >>> np.round(call_delta, 2) 0.79 >>> put_delta = blackscholes.delta( ... underlying_price, strike, expiry, sigma, put=True ... ) >>> np.round(put_delta, 2) -0.21 \"\"\" k = np . array ( np . log ( strike / underlying_price )) expiry , sigma = map ( np . array , ( expiry , sigma )) call_delta = _reduced_delta ( k , expiry , sigma ) return common . _put_call_parity_delta ( call_delta , put )","title":"Example"},{"location":"reference/blackscholes/#fyne.blackscholes.formula","text":"Black-Scholes formula Computes the price of the option according to the Black-Scholes formula.","title":"formula()"},{"location":"reference/blackscholes/#fyne.blackscholes.formula--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. put : bool, optional Whether the option is a put option. Defaults to False .","title":"Parameters"},{"location":"reference/blackscholes/#fyne.blackscholes.formula--returns","text":"float Option price according to Black-Scholes formula.","title":"Returns"},{"location":"reference/blackscholes/#fyne.blackscholes.formula--example","text":"import numpy as np from fyne import blackscholes sigma = 0.2 underlying_price = 100. strike = 90. expiry = 0.5 call_price = blackscholes.formula(underlying_price, strike, expiry, ... sigma) np.round(call_price, 2) 11.77 put_price = blackscholes.formula(underlying_price, strike, expiry, ... sigma, put=True) np.round(put_price, 2) 1.77 Source code in src/fyne/blackscholes.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def formula ( underlying_price , strike , expiry , sigma , put = False ): \"\"\"Black-Scholes formula Computes the price of the option according to the Black-Scholes formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option price according to Black-Scholes formula. Example ------- >>> import numpy as np >>> from fyne import blackscholes >>> sigma = 0.2 >>> underlying_price = 100. >>> strike = 90. >>> expiry = 0.5 >>> call_price = blackscholes.formula(underlying_price, strike, expiry, ... sigma) >>> np.round(call_price, 2) 11.77 >>> put_price = blackscholes.formula(underlying_price, strike, expiry, ... sigma, put=True) >>> np.round(put_price, 2) 1.77 \"\"\" k = np . array ( np . log ( strike / underlying_price )) expiry , sigma = map ( np . array , ( expiry , sigma )) call = _reduced_formula ( k , expiry , sigma ) * underlying_price return common . _put_call_parity ( call , underlying_price , strike , put )","title":"Example"},{"location":"reference/blackscholes/#fyne.blackscholes.implied_vol","text":"Implied volatility function Inverts the Black-Scholes formula to find the volatility that matches the given option price. The implied volatility is computed using Newton's method.","title":"implied_vol()"},{"location":"reference/blackscholes/#fyne.blackscholes.implied_vol--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. option_price : float Option price according to Black-Scholes formula. put : bool, optional Whether the option is a put option. Defaults to False . assert_no_arbitrage : bool, optional Whether to throw an exception upon no arbitrage bounds violation. Defaults to True .","title":"Parameters"},{"location":"reference/blackscholes/#fyne.blackscholes.implied_vol--returns","text":"float Implied volatility.","title":"Returns"},{"location":"reference/blackscholes/#fyne.blackscholes.implied_vol--example","text":"import numpy as np from fyne import blackscholes call_price = 11.77 put_price = 1.77 underlying_price = 100. strike = 90. expiry = 0.5 implied_vol = blackscholes.implied_vol(underlying_price, strike, ... expiry, call_price) np.round(implied_vol, 2) 0.2 implied_vol = blackscholes.implied_vol(underlying_price, strike, ... expiry, put_price, put=True) np.round(implied_vol, 2) 0.2 Source code in src/fyne/blackscholes.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def implied_vol ( underlying_price , strike , expiry , option_price , put = False , assert_no_arbitrage = True , ): \"\"\"Implied volatility function Inverts the Black-Scholes formula to find the volatility that matches the given option price. The implied volatility is computed using Newton's method. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. option_price : float Option price according to Black-Scholes formula. put : bool, optional Whether the option is a put option. Defaults to `False`. assert_no_arbitrage : bool, optional Whether to throw an exception upon no arbitrage bounds violation. Defaults to `True`. Returns ------- float Implied volatility. Example ------- >>> import numpy as np >>> from fyne import blackscholes >>> call_price = 11.77 >>> put_price = 1.77 >>> underlying_price = 100. >>> strike = 90. >>> expiry = 0.5 >>> implied_vol = blackscholes.implied_vol(underlying_price, strike, ... expiry, call_price) >>> np.round(implied_vol, 2) 0.2 >>> implied_vol = blackscholes.implied_vol(underlying_price, strike, ... expiry, put_price, put=True) >>> np.round(implied_vol, 2) 0.2 \"\"\" call = common . _put_call_parity_reverse ( option_price , underlying_price , strike , put ) if assert_no_arbitrage : common . _assert_no_arbitrage ( underlying_price , call , strike ) k = np . array ( np . log ( strike / underlying_price )) c = np . array ( call / underlying_price ) k , expiry , c = np . broadcast_arrays ( k , expiry , c ) is_otm = k > 0 k [ is_otm ] = - k [ is_otm ] c [ is_otm ] = 1 + np . exp ( k [ is_otm ]) * ( c [ is_otm ] - 1 ) noarb_mask = ~ np . any ( common . _check_arbitrage ( underlying_price , call , strike ), axis = 0 ) noarb_mask &= ~ np . any ( tuple ( map ( np . isnan , ( k , expiry , c ))), axis = 0 ) iv0 = np . maximum ( norm . ppf ( c [ noarb_mask ]), c [ noarb_mask ]) / np . sqrt ( expiry [ noarb_mask ] ) iv = np . full ( c . shape , np . nan ) iv [ noarb_mask ] = _reduced_implied_vol ( k [ noarb_mask ], expiry [ noarb_mask ], c [ noarb_mask ], iv0 ) return iv","title":"Example"},{"location":"reference/blackscholes/#fyne.blackscholes.vega","text":"Black-Scholes Greek vega Computes the Greek vega of the option -- i.e. the option price sensitivity with respect to its volatility parameter -- according to the Black-Scholes model. Note that the Greek vega is the same for calls and puts.","title":"vega()"},{"location":"reference/blackscholes/#fyne.blackscholes.vega--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter.","title":"Parameters"},{"location":"reference/blackscholes/#fyne.blackscholes.vega--returns","text":"float Greek vega according to Black-Scholes formula.","title":"Returns"},{"location":"reference/blackscholes/#fyne.blackscholes.vega--example","text":"import numpy as np from fyne import blackscholes sigma = 0.2 underlying_price = 100. strike = 90. maturity = 0.5 vega = blackscholes.vega(underlying_price, strike, maturity, sigma) np.round(vega, 2) 20.23 Source code in src/fyne/blackscholes.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def vega ( underlying_price , strike , expiry , sigma ): \"\"\"Black-Scholes Greek vega Computes the Greek vega of the option -- i.e. the option price sensitivity with respect to its volatility parameter -- according to the Black-Scholes model. Note that the Greek vega is the same for calls and puts. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. sigma : float Volatility parameter. Returns ------- float Greek vega according to Black-Scholes formula. Example ------- >>> import numpy as np >>> from fyne import blackscholes >>> sigma = 0.2 >>> underlying_price = 100. >>> strike = 90. >>> maturity = 0.5 >>> vega = blackscholes.vega(underlying_price, strike, maturity, sigma) >>> np.round(vega, 2) 20.23 \"\"\" k = np . array ( np . log ( strike / underlying_price )) expiry , sigma = map ( np . array , ( expiry , sigma )) return _reduced_vega ( k , expiry , sigma ) * underlying_price","title":"Example"},{"location":"reference/heston/","text":"Heston model calibration_crosssectional ( underlying_price , strikes , expiries , option_prices , initial_guess , put = False , weights = None , enforce_feller_cond = False ) Heston cross-sectional calibration Recovers the Heston model parameters from options prices at a single point in time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. initial_guess : tuple Initial guess for instantaneous volatility :math: V_0 as :obj:float and the Heston parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj:float. put : bool, optional Whether the option is a put option. Defaults to False . weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns tuple Returns the calibrated instantaneous volatility :math: V_0 and the Heston parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj: float . Example import numpy as np from fyne import heston vol, kappa, theta, nu, rho = 0.0457, 5.07, 0.0457, 0.48, -0.767 underlying_price = 1640. strikes = np.array([1312., 1312., 1640., 1640., 1968., 1968.]) expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) put = np.array([False, False, False, False, True, True]) option_prices = heston.formula(underlying_price, strikes, expiries, ... vol, kappa, theta, nu, rho, put) initial_guess = np.array([vol + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) calibrated = heston.calibration_crosssectional( ... underlying_price, strikes, expiries, option_prices, initial_guess, ... put) [np.round(param, 4) for param in calibrated] [0.0457, 5.07, 0.0457, 0.48, -0.767] Source code in src/fyne/heston.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def calibration_crosssectional ( underlying_price , strikes , expiries , option_prices , initial_guess , put = False , weights = None , enforce_feller_cond = False , ): r \"\"\"Heston cross-sectional calibration Recovers the Heston model parameters from options prices at a single point in time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. initial_guess : tuple Initial guess for instantaneous volatility :math:`V_0` as :obj:float and the Heston parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:float. put : bool, optional Whether the option is a put option. Defaults to `False`. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- tuple Returns the calibrated instantaneous volatility :math:`V_0` and the Heston parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:`float`. Example ------- >>> import numpy as np >>> from fyne import heston >>> vol, kappa, theta, nu, rho = 0.0457, 5.07, 0.0457, 0.48, -0.767 >>> underlying_price = 1640. >>> strikes = np.array([1312., 1312., 1640., 1640., 1968., 1968.]) >>> expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) >>> put = np.array([False, False, False, False, True, True]) >>> option_prices = heston.formula(underlying_price, strikes, expiries, ... vol, kappa, theta, nu, rho, put) >>> initial_guess = np.array([vol + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) >>> calibrated = heston.calibration_crosssectional( ... underlying_price, strikes, expiries, option_prices, initial_guess, ... put) >>> [np.round(param, 4) for param in calibrated] [0.0457, 5.07, 0.0457, 0.48, -0.767] \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_price , strikes , put ) cs = calls / underlying_price ks = np . log ( strikes / underlying_price ) ws = 1 / cs if weights is None else weights / cs vol0 , kappa0 , theta0 , nu0 , rho0 = initial_guess params = np . array ([ vol0 , kappa0 , kappa0 * theta0 , nu0 , rho0 ]) vol , kappa , a , nu , rho = _reduced_calib_xsect ( cs , ks , expiries , ws , params , enforce_feller_cond ) return vol , kappa , a / kappa , nu , rho calibration_panel ( underlying_prices , strikes , expiries , option_prices , initial_guess , put = False , weights = None ) Heston panel calibration Recovers the Heston model parameters from options prices across strikes, maturities and time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters underlying_price : numpy.array One-dimensional array of prices of the underlying asset at each point in time. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries array. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes array. option_prices : numpy.array Two-dimensional array of the call options prices. The array must be :math: n -by-:math: d , where :math: n is the size of underlying_price and :math: d is the size of strikes or expiries . initial_guess : tuple Initial guess for instantaneous volatility :math: V_0 as :obj:float and the Heston parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj:float. put : bool, optional Whether the option is a put option. Defaults to False . weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns tuple Returns the calibrated instantaneous volatilities :math: V_0 as a :obj: numpy.array and the Heston parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj: float . Example import numpy as np from fyne import heston kappa, theta, nu, rho = 5.07, 0.0457, 0.48, -0.767 underlying_prices = np.array([90., 100., 95.]) vols = np.array([0.05, 0.045, 0.055]) strikes = np.array([80., 80., 100., 100., 120., 120.]) expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) put = np.array([False, False, False, False, True, True]) option_prices = ( ... heston.formula(underlying_prices[:, None], strikes, expiries, ... vols[:, None], kappa, theta, nu, rho, put)) initial_guess = np.array([vols[1] + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) vols, kappa, theta, nu, rho = heston.calibration_panel( ... underlying_prices, strikes, expiries, option_prices, initial_guess, ... put) np.round(vols, 4) array([0.05 , 0.045, 0.055]) [np.round(param, 4) for param in (kappa, theta, nu, rho)] [5.07, 0.0457, 0.48, -0.767] Source code in src/fyne/heston.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def calibration_panel ( underlying_prices , strikes , expiries , option_prices , initial_guess , put = False , weights = None , ): r \"\"\"Heston panel calibration Recovers the Heston model parameters from options prices across strikes, maturities and time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : numpy.array One-dimensional array of prices of the underlying asset at each point in time. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries array. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes array. option_prices : numpy.array Two-dimensional array of the call options prices. The array must be :math:`n`-by-:math:`d`, where :math:`n` is the size of `underlying_price` and :math:`d` is the size of `strikes` or `expiries`. initial_guess : tuple Initial guess for instantaneous volatility :math:`V_0` as :obj:float and the Heston parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:float. put : bool, optional Whether the option is a put option. Defaults to `False`. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- tuple Returns the calibrated instantaneous volatilities :math:`V_0` as a :obj:`numpy.array` and the Heston parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:`float`. Example ------- >>> import numpy as np >>> from fyne import heston >>> kappa, theta, nu, rho = 5.07, 0.0457, 0.48, -0.767 >>> underlying_prices = np.array([90., 100., 95.]) >>> vols = np.array([0.05, 0.045, 0.055]) >>> strikes = np.array([80., 80., 100., 100., 120., 120.]) >>> expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) >>> put = np.array([False, False, False, False, True, True]) >>> option_prices = ( ... heston.formula(underlying_prices[:, None], strikes, expiries, ... vols[:, None], kappa, theta, nu, rho, put)) >>> initial_guess = np.array([vols[1] + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) >>> vols, kappa, theta, nu, rho = heston.calibration_panel( ... underlying_prices, strikes, expiries, option_prices, initial_guess, ... put) >>> np.round(vols, 4) array([0.05 , 0.045, 0.055]) >>> [np.round(param, 4) for param in (kappa, theta, nu, rho)] [5.07, 0.0457, 0.48, -0.767] \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_prices [:, None ], strikes , put ) cs = calls / underlying_prices [:, None ] ks = np . log ( strikes [ None , :] / underlying_prices [:, None ]) ws = 1 / cs if weights is None else weights / cs vol0 , kappa0 , theta0 , nu0 , rho0 = initial_guess params = vol0 * np . ones ( len ( underlying_prices ) + 4 ) params [ - 4 :] = kappa0 , kappa0 * theta0 , nu0 , rho0 calibrated = _reduced_calib_panel ( cs , ks , expiries , ws , params ) vols = calibrated [: - 4 ] kappa , a , nu , rho = calibrated [ - 4 :] return vols , kappa , a / kappa , nu , rho calibration_vol ( underlying_price , strikes , expiries , option_prices , kappa , theta , nu , rho , put = False , vol_guess = 0.1 , weights = None , n_cores = None ) Heston volatility calibration Recovers the Heston instantaneous volatility from options prices at a single point in time. The Heston model parameters must be provided. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. kappa : float Model parameter :math: \\kappa . theta : float Model parameter :math: \\theta . nu : float Model parameter :math: \\nu . rho : float Model parameter :math: \\rho . put : bool, optional Whether the option is a put option. Defaults to False . vol_guess : float, optional Initial guess for instantaneous volatility :math: V_0 . Defaults to 0.1. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns float Returns the calibrated instantaneous volatility :math: V_0 . Example import numpy as np from fyne import heston vol = 0.0457 params = (5.07, 0.0457, 0.48, -0.767) underlying_price = 1640. strikes = np.array([1312., 1312., 1640., 1640., 1968., 1968.]) expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) put = np.array([False, False, False, False, True, True]) option_prices = heston.formula( ... underlying_price, strikes, expiries, vol, params, put ... ) calibrated_vol = heston.calibration_vol( ... underlying_price, strikes, expiries, option_prices, params, put ... ) np.round(calibrated_vol, 4) 0.0457 Source code in src/fyne/heston.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def calibration_vol ( underlying_price , strikes , expiries , option_prices , kappa , theta , nu , rho , put = False , vol_guess = 0.1 , weights = None , n_cores = None , ): r \"\"\"Heston volatility calibration Recovers the Heston instantaneous volatility from options prices at a single point in time. The Heston model parameters must be provided. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. kappa : float Model parameter :math:`\\kappa`. theta : float Model parameter :math:`\\theta`. nu : float Model parameter :math:`\\nu`. rho : float Model parameter :math:`\\rho`. put : bool, optional Whether the option is a put option. Defaults to `False`. vol_guess : float, optional Initial guess for instantaneous volatility :math:`V_0`. Defaults to 0.1. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- float Returns the calibrated instantaneous volatility :math:`V_0`. Example ------- >>> import numpy as np >>> from fyne import heston >>> vol = 0.0457 >>> params = (5.07, 0.0457, 0.48, -0.767) >>> underlying_price = 1640. >>> strikes = np.array([1312., 1312., 1640., 1640., 1968., 1968.]) >>> expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) >>> put = np.array([False, False, False, False, True, True]) >>> option_prices = heston.formula( ... underlying_price, strikes, expiries, vol, *params, put ... ) >>> calibrated_vol = heston.calibration_vol( ... underlying_price, strikes, expiries, option_prices, *params, put ... ) >>> np.round(calibrated_vol, 4) 0.0457 \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_price , strikes , put ) cs = calls / underlying_price ks = np . log ( strikes / underlying_price ) ws = 1 / cs if weights is None else weights / cs ( vol ,) = _reduced_calib_vol ( cs , ks , expiries , ws , kappa , kappa * theta , nu , rho , np . array ([ vol_guess ]), n_cores = n_cores , ) return vol delta ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho , put = False ) Heston Greek delta Computes the Greek :math: \\Delta (delta) of the option according to the Heston formula. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math: \\kappa . theta : float Model parameter :math: \\theta . nu : float Model parameter :math: \\nu . rho : float Model parameter :math: \\rho . put : bool, optional Whether the option is a put option. Defaults to False . Returns float Option Greek :math: \\Delta (delta) according to Heston formula. Example import numpy as np from fyne import heston v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 underlying_price = 100. strike = 90. maturity = 0.5 call_delta = heston.delta(underlying_price, strike, maturity, v, kappa, ... theta, nu, rho) np.round(call_delta, 2) 0.72 put_delta = heston.delta(underlying_price, strike, maturity, v, kappa, ... theta, nu, rho, put=True) np.round(put_delta, 2) -0.28 Source code in src/fyne/heston.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def delta ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho , put = False ): r \"\"\"Heston Greek delta Computes the Greek :math:`\\Delta` (delta) of the option according to the Heston formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math:`\\kappa`. theta : float Model parameter :math:`\\theta`. nu : float Model parameter :math:`\\nu`. rho : float Model parameter :math:`\\rho`. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option Greek :math:`\\Delta` (delta) according to Heston formula. Example ------- >>> import numpy as np >>> from fyne import heston >>> v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 >>> underlying_price = 100. >>> strike = 90. >>> maturity = 0.5 >>> call_delta = heston.delta(underlying_price, strike, maturity, v, kappa, ... theta, nu, rho) >>> np.round(call_delta, 2) 0.72 >>> put_delta = heston.delta(underlying_price, strike, maturity, v, kappa, ... theta, nu, rho, put=True) >>> np.round(put_delta, 2) -0.28 \"\"\" k = np . log ( strike / underlying_price ) a = kappa * theta call_delta = _reduced_delta ( k , expiry , vol , kappa , a , nu , rho ) return common . _put_call_parity_delta ( call_delta , put ) formula ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho , put = False , assert_no_arbitrage = False ) Heston formula Computes the price of the option according to the Heston formula. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math: \\kappa . theta : float Model parameter :math: \\theta . nu : float Model parameter :math: \\nu . rho : float Model parameter :math: \\rho . put : bool, optional Whether the option is a put option. Defaults to False . Returns float Option price according to Heston formula. Example import numpy as np from fyne import heston v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 underlying_price = 100. strike = 90. expiry = 0.5 call_price = heston.formula(underlying_price, strike, expiry, v, kappa, ... theta, nu, rho) np.round(call_price, 2) 16.32 put_price = heston.formula(underlying_price, strike, expiry, v, kappa, ... theta, nu, rho, put=True) np.round(put_price, 2) 6.32 Source code in src/fyne/heston.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def formula ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho , put = False , assert_no_arbitrage = False , ): r \"\"\"Heston formula Computes the price of the option according to the Heston formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math:`\\kappa`. theta : float Model parameter :math:`\\theta`. nu : float Model parameter :math:`\\nu`. rho : float Model parameter :math:`\\rho`. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option price according to Heston formula. Example ------- >>> import numpy as np >>> from fyne import heston >>> v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 >>> underlying_price = 100. >>> strike = 90. >>> expiry = 0.5 >>> call_price = heston.formula(underlying_price, strike, expiry, v, kappa, ... theta, nu, rho) >>> np.round(call_price, 2) 16.32 >>> put_price = heston.formula(underlying_price, strike, expiry, v, kappa, ... theta, nu, rho, put=True) >>> np.round(put_price, 2) 6.32 \"\"\" ks = np . log ( strike / underlying_price ) a = kappa * theta broadcasted = np . broadcast ( ks , expiry , vol ) call = np . empty ( broadcasted . shape ) call . flat = [ _reduced_formula ( k , t , v , kappa , a , nu , rho , assert_no_arbitrage ) for ( k , t , v ) in broadcasted ] call *= underlying_price return common . _put_call_parity ( call , underlying_price , strike , put ) vega ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho ) Heston Greek vega Computes the Greek :math: \\mathcal{V} (vega) of the option according to the Heston formula. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math: \\kappa . theta : float Model parameter :math: \\theta . nu : float Model parameter :math: \\nu . rho : float Model parameter :math: \\rho . Returns float Option Greek :math: \\mathcal{V} (vega) according to Heston formula. Example import numpy as np from fyne import heston v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 underlying_price = 100. strike = 90. maturity = 0.5 vega = heston.vega(underlying_price, strike, maturity, v, kappa, theta, ... nu, rho) np.round(vega, 2) 22.5 Source code in src/fyne/heston.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def vega ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho ): r \"\"\"Heston Greek vega Computes the Greek :math:`\\mathcal{V}` (vega) of the option according to the Heston formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math:`\\kappa`. theta : float Model parameter :math:`\\theta`. nu : float Model parameter :math:`\\nu`. rho : float Model parameter :math:`\\rho`. Returns ------- float Option Greek :math:`\\mathcal{V}` (vega) according to Heston formula. Example ------- >>> import numpy as np >>> from fyne import heston >>> v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 >>> underlying_price = 100. >>> strike = 90. >>> maturity = 0.5 >>> vega = heston.vega(underlying_price, strike, maturity, v, kappa, theta, ... nu, rho) >>> np.round(vega, 2) 22.5 \"\"\" k = np . log ( strike / underlying_price ) a = kappa * theta return _reduced_vega ( k , expiry , vol , kappa , a , nu , rho ) * underlying_price","title":"Heston model"},{"location":"reference/heston/#heston-model","text":"","title":"Heston model"},{"location":"reference/heston/#fyne.heston.calibration_crosssectional","text":"Heston cross-sectional calibration Recovers the Heston model parameters from options prices at a single point in time. The calibration is performed using the Levenberg-Marquardt algorithm.","title":"calibration_crosssectional()"},{"location":"reference/heston/#fyne.heston.calibration_crosssectional--parameters","text":"underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. initial_guess : tuple Initial guess for instantaneous volatility :math: V_0 as :obj:float and the Heston parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj:float. put : bool, optional Whether the option is a put option. Defaults to False . weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays.","title":"Parameters"},{"location":"reference/heston/#fyne.heston.calibration_crosssectional--returns","text":"tuple Returns the calibrated instantaneous volatility :math: V_0 and the Heston parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj: float .","title":"Returns"},{"location":"reference/heston/#fyne.heston.calibration_crosssectional--example","text":"import numpy as np from fyne import heston vol, kappa, theta, nu, rho = 0.0457, 5.07, 0.0457, 0.48, -0.767 underlying_price = 1640. strikes = np.array([1312., 1312., 1640., 1640., 1968., 1968.]) expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) put = np.array([False, False, False, False, True, True]) option_prices = heston.formula(underlying_price, strikes, expiries, ... vol, kappa, theta, nu, rho, put) initial_guess = np.array([vol + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) calibrated = heston.calibration_crosssectional( ... underlying_price, strikes, expiries, option_prices, initial_guess, ... put) [np.round(param, 4) for param in calibrated] [0.0457, 5.07, 0.0457, 0.48, -0.767] Source code in src/fyne/heston.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def calibration_crosssectional ( underlying_price , strikes , expiries , option_prices , initial_guess , put = False , weights = None , enforce_feller_cond = False , ): r \"\"\"Heston cross-sectional calibration Recovers the Heston model parameters from options prices at a single point in time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. initial_guess : tuple Initial guess for instantaneous volatility :math:`V_0` as :obj:float and the Heston parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:float. put : bool, optional Whether the option is a put option. Defaults to `False`. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- tuple Returns the calibrated instantaneous volatility :math:`V_0` and the Heston parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:`float`. Example ------- >>> import numpy as np >>> from fyne import heston >>> vol, kappa, theta, nu, rho = 0.0457, 5.07, 0.0457, 0.48, -0.767 >>> underlying_price = 1640. >>> strikes = np.array([1312., 1312., 1640., 1640., 1968., 1968.]) >>> expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) >>> put = np.array([False, False, False, False, True, True]) >>> option_prices = heston.formula(underlying_price, strikes, expiries, ... vol, kappa, theta, nu, rho, put) >>> initial_guess = np.array([vol + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) >>> calibrated = heston.calibration_crosssectional( ... underlying_price, strikes, expiries, option_prices, initial_guess, ... put) >>> [np.round(param, 4) for param in calibrated] [0.0457, 5.07, 0.0457, 0.48, -0.767] \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_price , strikes , put ) cs = calls / underlying_price ks = np . log ( strikes / underlying_price ) ws = 1 / cs if weights is None else weights / cs vol0 , kappa0 , theta0 , nu0 , rho0 = initial_guess params = np . array ([ vol0 , kappa0 , kappa0 * theta0 , nu0 , rho0 ]) vol , kappa , a , nu , rho = _reduced_calib_xsect ( cs , ks , expiries , ws , params , enforce_feller_cond ) return vol , kappa , a / kappa , nu , rho","title":"Example"},{"location":"reference/heston/#fyne.heston.calibration_panel","text":"Heston panel calibration Recovers the Heston model parameters from options prices across strikes, maturities and time. The calibration is performed using the Levenberg-Marquardt algorithm.","title":"calibration_panel()"},{"location":"reference/heston/#fyne.heston.calibration_panel--parameters","text":"underlying_price : numpy.array One-dimensional array of prices of the underlying asset at each point in time. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries array. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes array. option_prices : numpy.array Two-dimensional array of the call options prices. The array must be :math: n -by-:math: d , where :math: n is the size of underlying_price and :math: d is the size of strikes or expiries . initial_guess : tuple Initial guess for instantaneous volatility :math: V_0 as :obj:float and the Heston parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj:float. put : bool, optional Whether the option is a put option. Defaults to False . weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays.","title":"Parameters"},{"location":"reference/heston/#fyne.heston.calibration_panel--returns","text":"tuple Returns the calibrated instantaneous volatilities :math: V_0 as a :obj: numpy.array and the Heston parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj: float .","title":"Returns"},{"location":"reference/heston/#fyne.heston.calibration_panel--example","text":"import numpy as np from fyne import heston kappa, theta, nu, rho = 5.07, 0.0457, 0.48, -0.767 underlying_prices = np.array([90., 100., 95.]) vols = np.array([0.05, 0.045, 0.055]) strikes = np.array([80., 80., 100., 100., 120., 120.]) expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) put = np.array([False, False, False, False, True, True]) option_prices = ( ... heston.formula(underlying_prices[:, None], strikes, expiries, ... vols[:, None], kappa, theta, nu, rho, put)) initial_guess = np.array([vols[1] + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) vols, kappa, theta, nu, rho = heston.calibration_panel( ... underlying_prices, strikes, expiries, option_prices, initial_guess, ... put) np.round(vols, 4) array([0.05 , 0.045, 0.055]) [np.round(param, 4) for param in (kappa, theta, nu, rho)] [5.07, 0.0457, 0.48, -0.767] Source code in src/fyne/heston.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def calibration_panel ( underlying_prices , strikes , expiries , option_prices , initial_guess , put = False , weights = None , ): r \"\"\"Heston panel calibration Recovers the Heston model parameters from options prices across strikes, maturities and time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : numpy.array One-dimensional array of prices of the underlying asset at each point in time. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries array. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes array. option_prices : numpy.array Two-dimensional array of the call options prices. The array must be :math:`n`-by-:math:`d`, where :math:`n` is the size of `underlying_price` and :math:`d` is the size of `strikes` or `expiries`. initial_guess : tuple Initial guess for instantaneous volatility :math:`V_0` as :obj:float and the Heston parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:float. put : bool, optional Whether the option is a put option. Defaults to `False`. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- tuple Returns the calibrated instantaneous volatilities :math:`V_0` as a :obj:`numpy.array` and the Heston parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:`float`. Example ------- >>> import numpy as np >>> from fyne import heston >>> kappa, theta, nu, rho = 5.07, 0.0457, 0.48, -0.767 >>> underlying_prices = np.array([90., 100., 95.]) >>> vols = np.array([0.05, 0.045, 0.055]) >>> strikes = np.array([80., 80., 100., 100., 120., 120.]) >>> expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) >>> put = np.array([False, False, False, False, True, True]) >>> option_prices = ( ... heston.formula(underlying_prices[:, None], strikes, expiries, ... vols[:, None], kappa, theta, nu, rho, put)) >>> initial_guess = np.array([vols[1] + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) >>> vols, kappa, theta, nu, rho = heston.calibration_panel( ... underlying_prices, strikes, expiries, option_prices, initial_guess, ... put) >>> np.round(vols, 4) array([0.05 , 0.045, 0.055]) >>> [np.round(param, 4) for param in (kappa, theta, nu, rho)] [5.07, 0.0457, 0.48, -0.767] \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_prices [:, None ], strikes , put ) cs = calls / underlying_prices [:, None ] ks = np . log ( strikes [ None , :] / underlying_prices [:, None ]) ws = 1 / cs if weights is None else weights / cs vol0 , kappa0 , theta0 , nu0 , rho0 = initial_guess params = vol0 * np . ones ( len ( underlying_prices ) + 4 ) params [ - 4 :] = kappa0 , kappa0 * theta0 , nu0 , rho0 calibrated = _reduced_calib_panel ( cs , ks , expiries , ws , params ) vols = calibrated [: - 4 ] kappa , a , nu , rho = calibrated [ - 4 :] return vols , kappa , a / kappa , nu , rho","title":"Example"},{"location":"reference/heston/#fyne.heston.calibration_vol","text":"Heston volatility calibration Recovers the Heston instantaneous volatility from options prices at a single point in time. The Heston model parameters must be provided. The calibration is performed using the Levenberg-Marquardt algorithm.","title":"calibration_vol()"},{"location":"reference/heston/#fyne.heston.calibration_vol--parameters","text":"underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. kappa : float Model parameter :math: \\kappa . theta : float Model parameter :math: \\theta . nu : float Model parameter :math: \\nu . rho : float Model parameter :math: \\rho . put : bool, optional Whether the option is a put option. Defaults to False . vol_guess : float, optional Initial guess for instantaneous volatility :math: V_0 . Defaults to 0.1. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays.","title":"Parameters"},{"location":"reference/heston/#fyne.heston.calibration_vol--returns","text":"float Returns the calibrated instantaneous volatility :math: V_0 .","title":"Returns"},{"location":"reference/heston/#fyne.heston.calibration_vol--example","text":"import numpy as np from fyne import heston vol = 0.0457 params = (5.07, 0.0457, 0.48, -0.767) underlying_price = 1640. strikes = np.array([1312., 1312., 1640., 1640., 1968., 1968.]) expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) put = np.array([False, False, False, False, True, True]) option_prices = heston.formula( ... underlying_price, strikes, expiries, vol, params, put ... ) calibrated_vol = heston.calibration_vol( ... underlying_price, strikes, expiries, option_prices, params, put ... ) np.round(calibrated_vol, 4) 0.0457 Source code in src/fyne/heston.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def calibration_vol ( underlying_price , strikes , expiries , option_prices , kappa , theta , nu , rho , put = False , vol_guess = 0.1 , weights = None , n_cores = None , ): r \"\"\"Heston volatility calibration Recovers the Heston instantaneous volatility from options prices at a single point in time. The Heston model parameters must be provided. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. kappa : float Model parameter :math:`\\kappa`. theta : float Model parameter :math:`\\theta`. nu : float Model parameter :math:`\\nu`. rho : float Model parameter :math:`\\rho`. put : bool, optional Whether the option is a put option. Defaults to `False`. vol_guess : float, optional Initial guess for instantaneous volatility :math:`V_0`. Defaults to 0.1. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- float Returns the calibrated instantaneous volatility :math:`V_0`. Example ------- >>> import numpy as np >>> from fyne import heston >>> vol = 0.0457 >>> params = (5.07, 0.0457, 0.48, -0.767) >>> underlying_price = 1640. >>> strikes = np.array([1312., 1312., 1640., 1640., 1968., 1968.]) >>> expiries = np.array([0.25, 0.5, 0.25, 0.5, 0.25, 0.5]) >>> put = np.array([False, False, False, False, True, True]) >>> option_prices = heston.formula( ... underlying_price, strikes, expiries, vol, *params, put ... ) >>> calibrated_vol = heston.calibration_vol( ... underlying_price, strikes, expiries, option_prices, *params, put ... ) >>> np.round(calibrated_vol, 4) 0.0457 \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_price , strikes , put ) cs = calls / underlying_price ks = np . log ( strikes / underlying_price ) ws = 1 / cs if weights is None else weights / cs ( vol ,) = _reduced_calib_vol ( cs , ks , expiries , ws , kappa , kappa * theta , nu , rho , np . array ([ vol_guess ]), n_cores = n_cores , ) return vol","title":"Example"},{"location":"reference/heston/#fyne.heston.delta","text":"Heston Greek delta Computes the Greek :math: \\Delta (delta) of the option according to the Heston formula.","title":"delta()"},{"location":"reference/heston/#fyne.heston.delta--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math: \\kappa . theta : float Model parameter :math: \\theta . nu : float Model parameter :math: \\nu . rho : float Model parameter :math: \\rho . put : bool, optional Whether the option is a put option. Defaults to False .","title":"Parameters"},{"location":"reference/heston/#fyne.heston.delta--returns","text":"float Option Greek :math: \\Delta (delta) according to Heston formula.","title":"Returns"},{"location":"reference/heston/#fyne.heston.delta--example","text":"import numpy as np from fyne import heston v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 underlying_price = 100. strike = 90. maturity = 0.5 call_delta = heston.delta(underlying_price, strike, maturity, v, kappa, ... theta, nu, rho) np.round(call_delta, 2) 0.72 put_delta = heston.delta(underlying_price, strike, maturity, v, kappa, ... theta, nu, rho, put=True) np.round(put_delta, 2) -0.28 Source code in src/fyne/heston.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def delta ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho , put = False ): r \"\"\"Heston Greek delta Computes the Greek :math:`\\Delta` (delta) of the option according to the Heston formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math:`\\kappa`. theta : float Model parameter :math:`\\theta`. nu : float Model parameter :math:`\\nu`. rho : float Model parameter :math:`\\rho`. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option Greek :math:`\\Delta` (delta) according to Heston formula. Example ------- >>> import numpy as np >>> from fyne import heston >>> v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 >>> underlying_price = 100. >>> strike = 90. >>> maturity = 0.5 >>> call_delta = heston.delta(underlying_price, strike, maturity, v, kappa, ... theta, nu, rho) >>> np.round(call_delta, 2) 0.72 >>> put_delta = heston.delta(underlying_price, strike, maturity, v, kappa, ... theta, nu, rho, put=True) >>> np.round(put_delta, 2) -0.28 \"\"\" k = np . log ( strike / underlying_price ) a = kappa * theta call_delta = _reduced_delta ( k , expiry , vol , kappa , a , nu , rho ) return common . _put_call_parity_delta ( call_delta , put )","title":"Example"},{"location":"reference/heston/#fyne.heston.formula","text":"Heston formula Computes the price of the option according to the Heston formula.","title":"formula()"},{"location":"reference/heston/#fyne.heston.formula--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math: \\kappa . theta : float Model parameter :math: \\theta . nu : float Model parameter :math: \\nu . rho : float Model parameter :math: \\rho . put : bool, optional Whether the option is a put option. Defaults to False .","title":"Parameters"},{"location":"reference/heston/#fyne.heston.formula--returns","text":"float Option price according to Heston formula.","title":"Returns"},{"location":"reference/heston/#fyne.heston.formula--example","text":"import numpy as np from fyne import heston v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 underlying_price = 100. strike = 90. expiry = 0.5 call_price = heston.formula(underlying_price, strike, expiry, v, kappa, ... theta, nu, rho) np.round(call_price, 2) 16.32 put_price = heston.formula(underlying_price, strike, expiry, v, kappa, ... theta, nu, rho, put=True) np.round(put_price, 2) 6.32 Source code in src/fyne/heston.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def formula ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho , put = False , assert_no_arbitrage = False , ): r \"\"\"Heston formula Computes the price of the option according to the Heston formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math:`\\kappa`. theta : float Model parameter :math:`\\theta`. nu : float Model parameter :math:`\\nu`. rho : float Model parameter :math:`\\rho`. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option price according to Heston formula. Example ------- >>> import numpy as np >>> from fyne import heston >>> v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 >>> underlying_price = 100. >>> strike = 90. >>> expiry = 0.5 >>> call_price = heston.formula(underlying_price, strike, expiry, v, kappa, ... theta, nu, rho) >>> np.round(call_price, 2) 16.32 >>> put_price = heston.formula(underlying_price, strike, expiry, v, kappa, ... theta, nu, rho, put=True) >>> np.round(put_price, 2) 6.32 \"\"\" ks = np . log ( strike / underlying_price ) a = kappa * theta broadcasted = np . broadcast ( ks , expiry , vol ) call = np . empty ( broadcasted . shape ) call . flat = [ _reduced_formula ( k , t , v , kappa , a , nu , rho , assert_no_arbitrage ) for ( k , t , v ) in broadcasted ] call *= underlying_price return common . _put_call_parity ( call , underlying_price , strike , put )","title":"Example"},{"location":"reference/heston/#fyne.heston.vega","text":"Heston Greek vega Computes the Greek :math: \\mathcal{V} (vega) of the option according to the Heston formula.","title":"vega()"},{"location":"reference/heston/#fyne.heston.vega--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math: \\kappa . theta : float Model parameter :math: \\theta . nu : float Model parameter :math: \\nu . rho : float Model parameter :math: \\rho .","title":"Parameters"},{"location":"reference/heston/#fyne.heston.vega--returns","text":"float Option Greek :math: \\mathcal{V} (vega) according to Heston formula.","title":"Returns"},{"location":"reference/heston/#fyne.heston.vega--example","text":"import numpy as np from fyne import heston v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 underlying_price = 100. strike = 90. maturity = 0.5 vega = heston.vega(underlying_price, strike, maturity, v, kappa, theta, ... nu, rho) np.round(vega, 2) 22.5 Source code in src/fyne/heston.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def vega ( underlying_price , strike , expiry , vol , kappa , theta , nu , rho ): r \"\"\"Heston Greek vega Computes the Greek :math:`\\mathcal{V}` (vega) of the option according to the Heston formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. kappa : float Model parameter :math:`\\kappa`. theta : float Model parameter :math:`\\theta`. nu : float Model parameter :math:`\\nu`. rho : float Model parameter :math:`\\rho`. Returns ------- float Option Greek :math:`\\mathcal{V}` (vega) according to Heston formula. Example ------- >>> import numpy as np >>> from fyne import heston >>> v, kappa, theta, nu, rho = 0.2, 1.3, 0.04, 0.4, -0.3 >>> underlying_price = 100. >>> strike = 90. >>> maturity = 0.5 >>> vega = heston.vega(underlying_price, strike, maturity, v, kappa, theta, ... nu, rho) >>> np.round(vega, 2) 22.5 \"\"\" k = np . log ( strike / underlying_price ) a = kappa * theta return _reduced_vega ( k , expiry , vol , kappa , a , nu , rho ) * underlying_price","title":"Example"},{"location":"reference/wishart/","text":"Wishart model calibration_crosssectional ( underlying_price , strikes , expiries , option_prices , initial_guess , put = False , weights = None , n_cores = None ) Wishart cross-sectional calibration Recovers the Wishart model parameters from options prices at a single point in time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. initial_guess : tuple Initial guess for instantaneous volatility matrix :math: \\Sigma_0 and the Wishart parameters :math: \\beta , :math: Q , :math: M and :math: R . put : bool, optional Whether the option is a put option. Defaults to False . weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns tuple Returns the calibrated instantaneous volatility :math: V_0 and the Wishart parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj: float . Example import numpy as np from fyne import wishart params = dict( vol=np.array([[0.0327, 0.0069], [0.0069, 0.0089]]), beta=0.6229, q=np.array([[0.3193, 0.2590], [0.2899, 0.2469]]), m=np.array([[-0.9858, -0.5224], [-0.1288, -0.9746]]), r=np.array([[-0.2116, -0.4428], [-0.2113, -0.5921]]), ) underlying_price = 1640. strikes = np.array([1148., 1148., 1148., 1148., ... 1312., 1312., 1312., 1312., ... 1640., 1640., 1640., 1640., ... 1968., 1968., 1968., 1968., ... 2296., 2296., 2296., 2296.]) expiries = np.array([0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5]) put = np.array([False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... True, True, True, True]) option_prices = wishart.formula(underlying_price, strikes, expiries, ... put=put, **params) initial_guess = np.array([vol + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) calibrated = heston.calibration_crosssectional( ... underlying_price, strikes, expiries, option_prices, initial_guess, ... put) [np.round(param, 4) for param in calibrated] [0.0457, 5.07, 0.0457, 0.48, -0.767] Source code in src/fyne/wishart/core.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def calibration_crosssectional ( underlying_price , strikes , expiries , option_prices , initial_guess , put = False , weights = None , n_cores = None , ): r \"\"\"Wishart cross-sectional calibration Recovers the Wishart model parameters from options prices at a single point in time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. initial_guess : tuple Initial guess for instantaneous volatility matrix :math:`\\Sigma_0` and the Wishart parameters :math:`\\beta`, :math:`Q`, :math:`M` and :math:`R`. put : bool, optional Whether the option is a put option. Defaults to `False`. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- tuple Returns the calibrated instantaneous volatility :math:`V_0` and the Wishart parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:`float`. Example ------- >>> import numpy as np >>> from fyne import wishart >>> params = dict( >>> vol=np.array([[0.0327, 0.0069], >>> [0.0069, 0.0089]]), >>> beta=0.6229, >>> q=np.array([[0.3193, 0.2590], >>> [0.2899, 0.2469]]), >>> m=np.array([[-0.9858, -0.5224], >>> [-0.1288, -0.9746]]), >>> r=np.array([[-0.2116, -0.4428], >>> [-0.2113, -0.5921]]), >>> ) >>> underlying_price = 1640. >>> strikes = np.array([1148., 1148., 1148., 1148., ... 1312., 1312., 1312., 1312., ... 1640., 1640., 1640., 1640., ... 1968., 1968., 1968., 1968., ... 2296., 2296., 2296., 2296.]) >>> expiries = np.array([0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5]) >>> put = np.array([False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... True, True, True, True]) >>> option_prices = wishart.formula(underlying_price, strikes, expiries, ... put=put, **params) >>> initial_guess = np.array([vol + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) >>> calibrated = heston.calibration_crosssectional( ... underlying_price, strikes, expiries, option_prices, initial_guess, ... put) >>> [np.round(param, 4) for param in calibrated] [0.0457, 5.07, 0.0457, 0.48, -0.767] \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_price , strikes , put ) cs = calls / underlying_price ks = np . log ( strikes / underlying_price ) ws = 1 / cs if weights is None else weights / cs vol0 , beta0 , q0 , m0 , r0 = initial_guess if vol0 . shape != ( 2 , 2 ): raise NotImplementedError ( \"Only 2-factor Wishart is currently available.\" ) return _reduced_calib_xsect ( cs , ks , expiries , ws , vol0 , beta0 , q0 , m0 , r0 , n_cores ) calibration_vol ( underlying_price , strikes , expiries , option_prices , vol_guess , beta , q , m , r , put = False , weights = None , n_cores = None ) Wishart volatility matrix calibration Recovers the Wishart instantaneous volatility matrix from options prices at a single point in time. The Wishart model parameters must be provided. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. vol_guess : float, optional Initial guess for instantaneous volatility :math: V_0 . Defaults to 0.1. beta: float Model parameter :math: \\beta . q : float matrix Model parameter :math: Q . m : float matrix Model parameter :math: M . r : float matrix Model parameter :math: R . put : bool, optional Whether the option is a put option. Defaults to False . weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns float Returns the calibrated instantaneous volatility :math: V_0 . Example import numpy as np from fyne import wishart params = dict( vol=np.array([[0.0327, 0.0069], [0.0069, 0.0089]]), beta=0.6229, q=np.array([[0.3193, 0.2590], [0.2899, 0.2469]]), m=np.array([[-0.9858, -0.5224], [-0.1288, -0.9746]]), r=np.array([[-0.2116, -0.4428], [-0.2113, -0.5921]]), ) underlying_price = 1640. strikes = np.array([1148., 1148., 1148., 1148., ... 1312., 1312., 1312., 1312., ... 1640., 1640., 1640., 1640., ... 1968., 1968., 1968., 1968., ... 2296., 2296., 2296., 2296.]) expiries = np.array([0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5]) put = np.array([False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... True, True, True, True]) option_prices = wishart.formula(underlying_price, strikes, expiries, ... put=put, **params) calibrated_vol = wishart.calibration_vol( ... underlying_price, strikes, expiries, option_prices, kappa, theta, ... nu, rho, put) np.round(calibrated_vol, 4) 0.0457 Source code in src/fyne/wishart/core.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 def calibration_vol ( underlying_price , strikes , expiries , option_prices , vol_guess , beta , q , m , r , put = False , weights = None , n_cores = None , ): r \"\"\"Wishart volatility matrix calibration Recovers the Wishart instantaneous volatility matrix from options prices at a single point in time. The Wishart model parameters must be provided. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. vol_guess : float, optional Initial guess for instantaneous volatility :math:`V_0`. Defaults to 0.1. beta: float Model parameter :math:`\\beta`. q : float matrix Model parameter :math:`Q`. m : float matrix Model parameter :math:`M`. r : float matrix Model parameter :math:`R`. put : bool, optional Whether the option is a put option. Defaults to `False`. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- float Returns the calibrated instantaneous volatility :math:`V_0`. Example ------- >>> import numpy as np >>> from fyne import wishart >>> params = dict( >>> vol=np.array([[0.0327, 0.0069], >>> [0.0069, 0.0089]]), >>> beta=0.6229, >>> q=np.array([[0.3193, 0.2590], >>> [0.2899, 0.2469]]), >>> m=np.array([[-0.9858, -0.5224], >>> [-0.1288, -0.9746]]), >>> r=np.array([[-0.2116, -0.4428], >>> [-0.2113, -0.5921]]), >>> ) >>> underlying_price = 1640. >>> strikes = np.array([1148., 1148., 1148., 1148., ... 1312., 1312., 1312., 1312., ... 1640., 1640., 1640., 1640., ... 1968., 1968., 1968., 1968., ... 2296., 2296., 2296., 2296.]) >>> expiries = np.array([0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5]) >>> put = np.array([False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... True, True, True, True]) >>> option_prices = wishart.formula(underlying_price, strikes, expiries, ... put=put, **params) >>> calibrated_vol = wishart.calibration_vol( ... underlying_price, strikes, expiries, option_prices, kappa, theta, ... nu, rho, put) >>> np.round(calibrated_vol, 4) 0.0457 \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_price , strikes , put ) cs = calls / underlying_price ks = np . log ( strikes / underlying_price ) ws = 1 / cs if weights is None else weights / cs return _reduced_calib_vol ( cs , ks , expiries , ws , vol_guess , beta , q , m , r , n_cores ) delta ( underlying_price , strike , expiry , vol , beta , q , m , r , put = False ) Wishart Greek delta Computes the Greek :math: \\Delta (delta) of the option according to the Wishart model. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. beta: float Model parameter :math: \\beta . q : float matrix Model parameter :math: Q . m : float matrix Model parameter :math: M . r : float matrix Model parameter :math: R . put : bool, optional Whether the option is a put option. Defaults to False . Returns float Option Greek :math: \\Delta (delta) according to Wishart formula. Source code in src/fyne/wishart/core.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def delta ( underlying_price , strike , expiry , vol , beta , q , m , r , put = False ): r \"\"\"Wishart Greek delta Computes the Greek :math:`\\Delta` (delta) of the option according to the Wishart model. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. beta: float Model parameter :math:`\\beta`. q : float matrix Model parameter :math:`Q`. m : float matrix Model parameter :math:`M`. r : float matrix Model parameter :math:`R`. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option Greek :math:`\\Delta` (delta) according to Wishart formula. \"\"\" k = np . log ( strike / underlying_price ) @np . vectorize def vec_reduced_delta ( k , t ): return _reduced_delta ( k , t , vol , beta , q , m , r ) call_delta = vec_reduced_delta ( k , expiry ) return common . _put_call_parity_delta ( call_delta , put ) formula ( underlying_price , strike , expiry , vol , beta , q , m , r , put = False , n_cores = None ) Wishart model formula Computes the price of the option according to the Wishart model formula. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float matrix Instantaneous volatility matrix. beta: float Model parameter :math: \\beta . q : float matrix Model parameter :math: Q . m : float matrix Model parameter :math: M . r : float matrix Model parameter :math: R . put : bool, optional Whether the option is a put option. Defaults to False . Returns float Option price according to Wishart model formula. Source code in src/fyne/wishart/core.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def formula ( underlying_price , strike , expiry , vol , beta , q , m , r , put = False , n_cores = None , ): r \"\"\"Wishart model formula Computes the price of the option according to the Wishart model formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float matrix Instantaneous volatility matrix. beta: float Model parameter :math:`\\beta`. q : float matrix Model parameter :math:`Q`. m : float matrix Model parameter :math:`M`. r : float matrix Model parameter :math:`R`. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option price according to Wishart model formula. \"\"\" if vol . shape != ( 2 , 2 ): raise NotImplementedError ( \"Only 2-factor Wishart is currently available.\" ) ks = np . log ( strike / underlying_price ) broadcasted = np . broadcast ( ks , expiry ) call = np . empty ( broadcasted . shape ) if n_cores is None : call . flat = [ _reduced_formula ( k , t , vol , beta , q , m , r ) for ( k , t ) in broadcasted ] else : with ProcessPoolExecutor ( max_workers = n_cores ) as executor : call . flat = list ( executor . map ( _reduced_formula , * zip ( * broadcasted ), * map ( repeat , ( vol , beta , q , m , r )), ) ) call *= underlying_price return common . _put_call_parity ( call , underlying_price , strike , put ) vega ( underlying_price , strike , expiry , vol , beta , q , m , r ) Wishart Greek vega Computes the Greek :math: \\mathcal{V} (vega) of the option according to the Wishart model. This is the gradient of the option price with respect to the volatility matrix. Parameters underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. beta: float Model parameter :math: \\beta . q : float matrix Model parameter :math: Q . m : float matrix Model parameter :math: M . r : float matrix Model parameter :math: R . Returns float Option Greek :math: \\mathcal{V} (vega) according to Wishart formula. Source code in src/fyne/wishart/core.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def vega ( underlying_price , strike , expiry , vol , beta , q , m , r ): r \"\"\"Wishart Greek vega Computes the Greek :math:`\\mathcal{V}` (vega) of the option according to the Wishart model. This is the gradient of the option price with respect to the volatility matrix. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. beta: float Model parameter :math:`\\beta`. q : float matrix Model parameter :math:`Q`. m : float matrix Model parameter :math:`M`. r : float matrix Model parameter :math:`R`. Returns ------- float Option Greek :math:`\\mathcal{V}` (vega) according to Wishart formula. \"\"\" k = np . log ( strike / underlying_price ) @np . vectorize def vec_reduced_vega ( k , t ): return _reduced_vega ( k , t , vol , beta , q , m , r ) return vec_reduced_vega ( k , expiry ) * underlying_price","title":"Wishart model"},{"location":"reference/wishart/#wishart-model","text":"","title":"Wishart model"},{"location":"reference/wishart/#fyne.wishart.calibration_crosssectional","text":"Wishart cross-sectional calibration Recovers the Wishart model parameters from options prices at a single point in time. The calibration is performed using the Levenberg-Marquardt algorithm.","title":"calibration_crosssectional()"},{"location":"reference/wishart/#fyne.wishart.calibration_crosssectional--parameters","text":"underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. initial_guess : tuple Initial guess for instantaneous volatility matrix :math: \\Sigma_0 and the Wishart parameters :math: \\beta , :math: Q , :math: M and :math: R . put : bool, optional Whether the option is a put option. Defaults to False . weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays.","title":"Parameters"},{"location":"reference/wishart/#fyne.wishart.calibration_crosssectional--returns","text":"tuple Returns the calibrated instantaneous volatility :math: V_0 and the Wishart parameters :math: \\kappa , :math: \\theta , :math: \\nu and :math: \\rho , respectively, as :obj: float .","title":"Returns"},{"location":"reference/wishart/#fyne.wishart.calibration_crosssectional--example","text":"import numpy as np from fyne import wishart params = dict( vol=np.array([[0.0327, 0.0069], [0.0069, 0.0089]]), beta=0.6229, q=np.array([[0.3193, 0.2590], [0.2899, 0.2469]]), m=np.array([[-0.9858, -0.5224], [-0.1288, -0.9746]]), r=np.array([[-0.2116, -0.4428], [-0.2113, -0.5921]]), ) underlying_price = 1640. strikes = np.array([1148., 1148., 1148., 1148., ... 1312., 1312., 1312., 1312., ... 1640., 1640., 1640., 1640., ... 1968., 1968., 1968., 1968., ... 2296., 2296., 2296., 2296.]) expiries = np.array([0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5]) put = np.array([False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... True, True, True, True]) option_prices = wishart.formula(underlying_price, strikes, expiries, ... put=put, **params) initial_guess = np.array([vol + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) calibrated = heston.calibration_crosssectional( ... underlying_price, strikes, expiries, option_prices, initial_guess, ... put) [np.round(param, 4) for param in calibrated] [0.0457, 5.07, 0.0457, 0.48, -0.767] Source code in src/fyne/wishart/core.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def calibration_crosssectional ( underlying_price , strikes , expiries , option_prices , initial_guess , put = False , weights = None , n_cores = None , ): r \"\"\"Wishart cross-sectional calibration Recovers the Wishart model parameters from options prices at a single point in time. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. initial_guess : tuple Initial guess for instantaneous volatility matrix :math:`\\Sigma_0` and the Wishart parameters :math:`\\beta`, :math:`Q`, :math:`M` and :math:`R`. put : bool, optional Whether the option is a put option. Defaults to `False`. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- tuple Returns the calibrated instantaneous volatility :math:`V_0` and the Wishart parameters :math:`\\kappa`, :math:`\\theta`, :math:`\\nu` and :math:`\\rho`, respectively, as :obj:`float`. Example ------- >>> import numpy as np >>> from fyne import wishart >>> params = dict( >>> vol=np.array([[0.0327, 0.0069], >>> [0.0069, 0.0089]]), >>> beta=0.6229, >>> q=np.array([[0.3193, 0.2590], >>> [0.2899, 0.2469]]), >>> m=np.array([[-0.9858, -0.5224], >>> [-0.1288, -0.9746]]), >>> r=np.array([[-0.2116, -0.4428], >>> [-0.2113, -0.5921]]), >>> ) >>> underlying_price = 1640. >>> strikes = np.array([1148., 1148., 1148., 1148., ... 1312., 1312., 1312., 1312., ... 1640., 1640., 1640., 1640., ... 1968., 1968., 1968., 1968., ... 2296., 2296., 2296., 2296.]) >>> expiries = np.array([0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5]) >>> put = np.array([False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... True, True, True, True]) >>> option_prices = wishart.formula(underlying_price, strikes, expiries, ... put=put, **params) >>> initial_guess = np.array([vol + 0.01, kappa + 1, theta + 0.01, ... nu - 0.1, rho - 0.1]) >>> calibrated = heston.calibration_crosssectional( ... underlying_price, strikes, expiries, option_prices, initial_guess, ... put) >>> [np.round(param, 4) for param in calibrated] [0.0457, 5.07, 0.0457, 0.48, -0.767] \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_price , strikes , put ) cs = calls / underlying_price ks = np . log ( strikes / underlying_price ) ws = 1 / cs if weights is None else weights / cs vol0 , beta0 , q0 , m0 , r0 = initial_guess if vol0 . shape != ( 2 , 2 ): raise NotImplementedError ( \"Only 2-factor Wishart is currently available.\" ) return _reduced_calib_xsect ( cs , ks , expiries , ws , vol0 , beta0 , q0 , m0 , r0 , n_cores )","title":"Example"},{"location":"reference/wishart/#fyne.wishart.calibration_vol","text":"Wishart volatility matrix calibration Recovers the Wishart instantaneous volatility matrix from options prices at a single point in time. The Wishart model parameters must be provided. The calibration is performed using the Levenberg-Marquardt algorithm.","title":"calibration_vol()"},{"location":"reference/wishart/#fyne.wishart.calibration_vol--parameters","text":"underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. vol_guess : float, optional Initial guess for instantaneous volatility :math: V_0 . Defaults to 0.1. beta: float Model parameter :math: \\beta . q : float matrix Model parameter :math: Q . m : float matrix Model parameter :math: M . r : float matrix Model parameter :math: R . put : bool, optional Whether the option is a put option. Defaults to False . weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays.","title":"Parameters"},{"location":"reference/wishart/#fyne.wishart.calibration_vol--returns","text":"float Returns the calibrated instantaneous volatility :math: V_0 .","title":"Returns"},{"location":"reference/wishart/#fyne.wishart.calibration_vol--example","text":"import numpy as np from fyne import wishart params = dict( vol=np.array([[0.0327, 0.0069], [0.0069, 0.0089]]), beta=0.6229, q=np.array([[0.3193, 0.2590], [0.2899, 0.2469]]), m=np.array([[-0.9858, -0.5224], [-0.1288, -0.9746]]), r=np.array([[-0.2116, -0.4428], [-0.2113, -0.5921]]), ) underlying_price = 1640. strikes = np.array([1148., 1148., 1148., 1148., ... 1312., 1312., 1312., 1312., ... 1640., 1640., 1640., 1640., ... 1968., 1968., 1968., 1968., ... 2296., 2296., 2296., 2296.]) expiries = np.array([0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5]) put = np.array([False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... True, True, True, True]) option_prices = wishart.formula(underlying_price, strikes, expiries, ... put=put, **params) calibrated_vol = wishart.calibration_vol( ... underlying_price, strikes, expiries, option_prices, kappa, theta, ... nu, rho, put) np.round(calibrated_vol, 4) 0.0457 Source code in src/fyne/wishart/core.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 def calibration_vol ( underlying_price , strikes , expiries , option_prices , vol_guess , beta , q , m , r , put = False , weights = None , n_cores = None , ): r \"\"\"Wishart volatility matrix calibration Recovers the Wishart instantaneous volatility matrix from options prices at a single point in time. The Wishart model parameters must be provided. The calibration is performed using the Levenberg-Marquardt algorithm. Parameters ---------- underlying_price : float Price of the underlying asset. strikes : numpy.array One-dimensional array of option strikes. Must be of the same length as the expiries and option_prices arrays. expiries : numpy.array One-dimensional array of option expiries. The expiries are the time remaining until the expiry of the option. Must be of the same length as the strikes and option_prices arrays. option_prices : numpy.array One-dimensional array of call options prices. Must be of the same length as the expiries and strikes arrays. vol_guess : float, optional Initial guess for instantaneous volatility :math:`V_0`. Defaults to 0.1. beta: float Model parameter :math:`\\beta`. q : float matrix Model parameter :math:`Q`. m : float matrix Model parameter :math:`M`. r : float matrix Model parameter :math:`R`. put : bool, optional Whether the option is a put option. Defaults to `False`. weights : numpy.array, optional One-dimensional array of call options prices. Must be of the same length as the option_prices, expiries and strikes arrays. Returns ------- float Returns the calibrated instantaneous volatility :math:`V_0`. Example ------- >>> import numpy as np >>> from fyne import wishart >>> params = dict( >>> vol=np.array([[0.0327, 0.0069], >>> [0.0069, 0.0089]]), >>> beta=0.6229, >>> q=np.array([[0.3193, 0.2590], >>> [0.2899, 0.2469]]), >>> m=np.array([[-0.9858, -0.5224], >>> [-0.1288, -0.9746]]), >>> r=np.array([[-0.2116, -0.4428], >>> [-0.2113, -0.5921]]), >>> ) >>> underlying_price = 1640. >>> strikes = np.array([1148., 1148., 1148., 1148., ... 1312., 1312., 1312., 1312., ... 1640., 1640., 1640., 1640., ... 1968., 1968., 1968., 1968., ... 2296., 2296., 2296., 2296.]) >>> expiries = np.array([0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5, ... 0.12, 0.19, 0.25, 0.5]) >>> put = np.array([False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... False, False, False, False, ... True, True, True, True]) >>> option_prices = wishart.formula(underlying_price, strikes, expiries, ... put=put, **params) >>> calibrated_vol = wishart.calibration_vol( ... underlying_price, strikes, expiries, option_prices, kappa, theta, ... nu, rho, put) >>> np.round(calibrated_vol, 4) 0.0457 \"\"\" calls = common . _put_call_parity_reverse ( option_prices , underlying_price , strikes , put ) cs = calls / underlying_price ks = np . log ( strikes / underlying_price ) ws = 1 / cs if weights is None else weights / cs return _reduced_calib_vol ( cs , ks , expiries , ws , vol_guess , beta , q , m , r , n_cores )","title":"Example"},{"location":"reference/wishart/#fyne.wishart.delta","text":"Wishart Greek delta Computes the Greek :math: \\Delta (delta) of the option according to the Wishart model.","title":"delta()"},{"location":"reference/wishart/#fyne.wishart.delta--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. beta: float Model parameter :math: \\beta . q : float matrix Model parameter :math: Q . m : float matrix Model parameter :math: M . r : float matrix Model parameter :math: R . put : bool, optional Whether the option is a put option. Defaults to False .","title":"Parameters"},{"location":"reference/wishart/#fyne.wishart.delta--returns","text":"float Option Greek :math: \\Delta (delta) according to Wishart formula. Source code in src/fyne/wishart/core.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def delta ( underlying_price , strike , expiry , vol , beta , q , m , r , put = False ): r \"\"\"Wishart Greek delta Computes the Greek :math:`\\Delta` (delta) of the option according to the Wishart model. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. beta: float Model parameter :math:`\\beta`. q : float matrix Model parameter :math:`Q`. m : float matrix Model parameter :math:`M`. r : float matrix Model parameter :math:`R`. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option Greek :math:`\\Delta` (delta) according to Wishart formula. \"\"\" k = np . log ( strike / underlying_price ) @np . vectorize def vec_reduced_delta ( k , t ): return _reduced_delta ( k , t , vol , beta , q , m , r ) call_delta = vec_reduced_delta ( k , expiry ) return common . _put_call_parity_delta ( call_delta , put )","title":"Returns"},{"location":"reference/wishart/#fyne.wishart.formula","text":"Wishart model formula Computes the price of the option according to the Wishart model formula.","title":"formula()"},{"location":"reference/wishart/#fyne.wishart.formula--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float matrix Instantaneous volatility matrix. beta: float Model parameter :math: \\beta . q : float matrix Model parameter :math: Q . m : float matrix Model parameter :math: M . r : float matrix Model parameter :math: R . put : bool, optional Whether the option is a put option. Defaults to False .","title":"Parameters"},{"location":"reference/wishart/#fyne.wishart.formula--returns","text":"float Option price according to Wishart model formula. Source code in src/fyne/wishart/core.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def formula ( underlying_price , strike , expiry , vol , beta , q , m , r , put = False , n_cores = None , ): r \"\"\"Wishart model formula Computes the price of the option according to the Wishart model formula. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float matrix Instantaneous volatility matrix. beta: float Model parameter :math:`\\beta`. q : float matrix Model parameter :math:`Q`. m : float matrix Model parameter :math:`M`. r : float matrix Model parameter :math:`R`. put : bool, optional Whether the option is a put option. Defaults to `False`. Returns ------- float Option price according to Wishart model formula. \"\"\" if vol . shape != ( 2 , 2 ): raise NotImplementedError ( \"Only 2-factor Wishart is currently available.\" ) ks = np . log ( strike / underlying_price ) broadcasted = np . broadcast ( ks , expiry ) call = np . empty ( broadcasted . shape ) if n_cores is None : call . flat = [ _reduced_formula ( k , t , vol , beta , q , m , r ) for ( k , t ) in broadcasted ] else : with ProcessPoolExecutor ( max_workers = n_cores ) as executor : call . flat = list ( executor . map ( _reduced_formula , * zip ( * broadcasted ), * map ( repeat , ( vol , beta , q , m , r )), ) ) call *= underlying_price return common . _put_call_parity ( call , underlying_price , strike , put )","title":"Returns"},{"location":"reference/wishart/#fyne.wishart.vega","text":"Wishart Greek vega Computes the Greek :math: \\mathcal{V} (vega) of the option according to the Wishart model. This is the gradient of the option price with respect to the volatility matrix.","title":"vega()"},{"location":"reference/wishart/#fyne.wishart.vega--parameters","text":"underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. beta: float Model parameter :math: \\beta . q : float matrix Model parameter :math: Q . m : float matrix Model parameter :math: M . r : float matrix Model parameter :math: R .","title":"Parameters"},{"location":"reference/wishart/#fyne.wishart.vega--returns","text":"float Option Greek :math: \\mathcal{V} (vega) according to Wishart formula. Source code in src/fyne/wishart/core.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def vega ( underlying_price , strike , expiry , vol , beta , q , m , r ): r \"\"\"Wishart Greek vega Computes the Greek :math:`\\mathcal{V}` (vega) of the option according to the Wishart model. This is the gradient of the option price with respect to the volatility matrix. Parameters ---------- underlying_price : float Price of the underlying asset. strike : float Strike of the option. expiry : float Time remaining until the expiry of the option. vol : float Instantaneous volatility. beta: float Model parameter :math:`\\beta`. q : float matrix Model parameter :math:`Q`. m : float matrix Model parameter :math:`M`. r : float matrix Model parameter :math:`R`. Returns ------- float Option Greek :math:`\\mathcal{V}` (vega) according to Wishart formula. \"\"\" k = np . log ( strike / underlying_price ) @np . vectorize def vec_reduced_vega ( k , t ): return _reduced_vega ( k , t , vol , beta , q , m , r ) return vec_reduced_vega ( k , expiry ) * underlying_price","title":"Returns"}]}